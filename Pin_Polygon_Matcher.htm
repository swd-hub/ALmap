<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON åº§æ¨™ã«ã‚ˆã‚‹ç©ºé–“æŠ½å‡ºãƒ„ãƒ¼ãƒ«</title>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            margin: 20px;
            background-color: #f0f2f5;
            color: #333;
        }
        h1 {
            color: #17a2b8;
            text-align: center;
            border-bottom: 3px solid #17a2b8;
            padding-bottom: 10px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .input-section {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }
        .input-group {
            flex: 1;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        h2 {
            font-size: 1.2em;
            color: #17a2b8;
            margin-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            display: block;
            width: 100%;
            margin-top: 20px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .output-section {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }
        .output-box {
            flex: 1;
        }
        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            background-color: #f9f9f9;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        .message {
            margin-top: 15px;
            padding: 15px;
            border-radius: 4px;
            display: none;
            white-space: pre-wrap;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>GeoJSON åº§æ¨™ã«ã‚ˆã‚‹ç©ºé–“æŠ½å‡ºãƒ„ãƒ¼ãƒ« (BBoxãƒ•ã‚£ãƒ«ã‚¿ãƒ¼)</h1>
        <p>ğŸ“ ãƒ”ãƒ³ (Point) ãƒ‡ãƒ¼ã‚¿ã®å…¨åº§æ¨™ã‹ã‚‰å››è§’å½¢ã®ç¯„å›² (BBox) ã‚’è¨ˆç®—ã—ã€ãã®ç¯„å›²ã¨äº¤å·®ã™ã‚‹ ğŸ—ºï¸ ãƒãƒªã‚´ãƒ³ (Polygon) ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã—ã¾ã™ã€‚</p>

        <div class="input-section">
            
            <div class="input-group" style="background-color: #f8f9fa;">
                <h2>ğŸ“ ãƒ”ãƒ³ (Point) ãƒ‡ãƒ¼ã‚¿ (æ¤œç´¢ç¯„å›²ã‚’å®šç¾©)</h2>
                <label for="pinFile">GeoJSONãƒ•ã‚¡ã‚¤ãƒ« (.geojson, .json):</label>
                <input type="file" id="pinFile" accept=".json,.geojson">
            </div>

            <div class="input-group" style="background-color: #f8f9fa;">
                <h2>ğŸ—ºï¸ ãƒãƒªã‚´ãƒ³ (Polygon) ãƒ‡ãƒ¼ã‚¿ (æŠ½å‡ºå¯¾è±¡)</h2>
                <label for="polyFile">GeoJSONãƒ•ã‚¡ã‚¤ãƒ« (.geojson, .json):</label>
                <input type="file" id="polyFile" accept=".json,.geojson">
            </div>
            
        </div>
        
        <button onclick="matchFeatures()" id="processBtn">åº§æ¨™ã§æŠ½å‡ºã—ã¦å¯¾å¿œãƒ‡ãƒ¼ã‚¿ã‚’å‡ºåŠ›</button>
        <div id="statusMessage" class="message"></div>
        
        <div class="output-section">
            <div class="output-box">
                <h2>å‡ºåŠ› 1: æŠ½å‡ºã«ä½¿ç”¨ã—ãŸãƒ”ãƒ³ GeoJSON</h2>
                <textarea id="matchedPinsOutput" readonly placeholder="çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™..."></textarea>
                <button onclick="downloadResult('pins')" id="downloadPinsBtn" style="display:none; background-color: #28a745;">ãƒ”ãƒ³ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            </div>
            <div class="output-box">
                <h2>å‡ºåŠ› 2: æŠ½å‡ºã•ã‚ŒãŸãƒãƒªã‚´ãƒ³ GeoJSON</h2>
                <textarea id="matchedPolygonsOutput" readonly placeholder="çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™..."></textarea>
                <button onclick="downloadResult('polygons')" id="downloadPolygonsBtn" style="display:none; background-color: #28a745;">ãƒãƒªã‚´ãƒ³ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            </div>
        </div>
    </div>

    <script>
        let matchedPinsString = "";
        let matchedPolygonsString = "";

        // -----------------------------------------------------------
        // 1. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        // -----------------------------------------------------------

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’éåŒæœŸã§èª­ã¿è¾¼ã‚€æ±ç”¨é–¢æ•°
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    try {
                        const parsed = JSON.parse(e.target.result);
                        if (typeof parsed !== 'object' || parsed === null) {
                            reject(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã®å†…å®¹ãŒä¸æ­£ã§ã™ã€‚`);
                            return;
                        }
                        resolve(parsed);
                    } catch (err) {
                        reject(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã¯æœ‰åŠ¹ãªGeoJSONã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`);
                    }
                };
                reader.onerror = () => reject(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`);
                reader.readAsText(file);
            });
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºé–¢æ•°
        function showMsg(text, isError = false) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = text;
            statusDiv.className = isError ? "message error" : "message success";
            statusDiv.style.display = "block";
        }

        /**
         * è¤‡æ•°ã®Pointãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‹ã‚‰ã€ãã‚Œã‚‰ã‚’åŒ…å«ã™ã‚‹BBox [minLng, minLat, maxLng, maxLat] ã‚’è¨ˆç®—ã™ã‚‹ã€‚
         */
        function calculatePinBBox(pinFeatures) {
            let minLng = Infinity, maxLng = -Infinity;
            let minLat = Infinity, maxLat = -Infinity;

            pinFeatures.forEach(f => {
                if (f.geometry && f.geometry.type === 'Point' && f.geometry.coordinates) {
                    const [lng, lat] = f.geometry.coordinates;
                    minLng = Math.min(minLng, lng);
                    maxLng = Math.max(maxLng, lng);
                    minLat = Math.min(minLat, lat);
                    maxLat = Math.max(maxLat, lat);
                }
            });

            if (minLng === Infinity) return null;
            return [minLng, minLat, maxLng, maxLat];
        }

        /**
         * Polygon/MultiPolygonãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‹ã‚‰ã€ãã®ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‚’åŒ…å«ã™ã‚‹BBoxã‚’è¨ˆç®—ã™ã‚‹ã€‚
         * BBox: [minLng, minLat, maxLng, maxLat]
         */
        function getFeatureBBox(feature) {
            let minLng = Infinity, maxLng = -Infinity;
            let minLat = Infinity, maxLat = -Infinity;
            
            if (!feature.geometry || !feature.geometry.coordinates) return null;

            const extractCoords = (coords) => {
                // Polygon/LineString (coordinates: [ [lng, lat], ... ])
                if (typeof coords[0][0] === 'number') { 
                    coords.forEach(([lng, lat]) => {
                        minLng = Math.min(minLng, lng);
                        maxLng = Math.max(maxLng, lng);
                        minLat = Math.min(minLat, lat);
                        maxLat = Math.max(maxLat, lat);
                    });
                } 
                // MultiPolygon/Polygon with holes (coordinates: [ [ [lng, lat], ... ], ... ])
                else {
                    coords.forEach(ring => extractCoords(ring));
                }
            };
            
            extractCoords(feature.geometry.coordinates);

            if (minLng === Infinity) return null;
            return [minLng, minLat, maxLng, maxLat];
        }

        /**
         * 2ã¤ã®BBoxãŒäº¤å·®ã™ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã€‚
         * bbox: [minLng, minLat, maxLng, maxLat]
         */
        function checkBBoxIntersection(bbox1, bbox2) {
            const [minLng1, minLat1, maxLng1, maxLat1] = bbox1;
            const [minLng2, minLat2, maxLng2, maxLat2] = bbox2;

            return maxLng1 >= minLng2 && 
                   minLng1 <= maxLng2 &&
                   maxLat1 >= minLat2 &&
                   minLat1 <= maxLat2;
        }

        // -----------------------------------------------------------
        // 2. ãƒ¡ã‚¤ãƒ³å‡¦ç†é–¢æ•°
        // -----------------------------------------------------------

        async function matchFeatures() {
            const pinFileInput = document.getElementById('pinFile');
            const polyFileInput = document.getElementById('polyFile');
            const processBtn = document.getElementById('processBtn');

            // åˆæœŸè¡¨ç¤ºã‚¯ãƒªã‚¢
            document.getElementById('matchedPinsOutput').value = '';
            document.getElementById('matchedPolygonsOutput').value = '';
            document.getElementById('downloadPinsBtn').style.display = 'none';
            document.getElementById('downloadPolygonsBtn').style.display = 'none';
            document.getElementById('statusMessage').style.display = 'none';

            if (pinFileInput.files.length === 0 || polyFileInput.files.length === 0) {
                showMsg('ãƒ”ãƒ³GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ãƒãƒªã‚´ãƒ³GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸¡æ–¹ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', true);
                return;
            }

            processBtn.disabled = true;
            processBtn.textContent = "åº§æ¨™ç…§åˆä¸­...";

            try {
                // 1. ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã¨ãƒ‘ãƒ¼ã‚¹
                const pinData = await readFileAsync(pinFileInput.files[0]);
                const polyData = await readFileAsync(polyFileInput.files[0]);

                const pinFeatures = (pinData.features || (pinData.type === 'Feature' ? [pinData] : [])).filter(f => f.geometry && f.geometry.type === 'Point');
                const polyFeatures = (polyData.features || (polyData.type === 'Feature' ? [polyData] : [])).filter(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));

                if (pinFeatures.length === 0) {
                    throw new Error("ãƒ”ãƒ³GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã«Pointãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
                }
                if (polyFeatures.length === 0) {
                    throw new Error("ãƒãƒªã‚´ãƒ³GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã«Polygonãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
                }
                
                // 2. ãƒ”ãƒ³ã®BBoxï¼ˆæ¤œç´¢ç¯„å›²ï¼‰ã‚’è¨ˆç®—
                const pinBBox = calculatePinBBox(pinFeatures);
                if (!pinBBox) {
                     throw new Error("ãƒ”ãƒ³ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‹ã‚‰æœ‰åŠ¹ãªåº§æ¨™ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚");
                }

                // 3. ãƒãƒªã‚´ãƒ³ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                const matchedPolygons = [];
                polyFeatures.forEach(poly => {
                    const polyBBox = getFeatureBBox(poly);
                    
                    if (polyBBox && checkBBoxIntersection(pinBBox, polyBBox)) {
                        matchedPolygons.push(poly);
                    }
                });

                // 4. çµæœã®GeoJSONæ§‹ç¯‰ã¨è¡¨ç¤º
                const resultPins = { type: "FeatureCollection", features: pinFeatures }; // å…¨ãƒ”ãƒ³ã¯ãã®ã¾ã¾å‡ºåŠ› (æ¤œç´¢ç¯„å›²ã®å®šç¾©ã¨ã—ã¦)
                const resultPolygons = { type: "FeatureCollection", features: matchedPolygons };

                // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«çµæœã‚’æ ¼ç´ (ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨)
                matchedPinsString = JSON.stringify(resultPins, null, 2);
                matchedPolygonsString = JSON.stringify(resultPolygons, null, 2);
                
                document.getElementById('matchedPinsOutput').value = matchedPinsString;
                document.getElementById('matchedPolygonsOutput').value = matchedPolygonsString;
                
                document.getElementById('downloadPinsBtn').style.display = 'block';
                document.getElementById('downloadPolygonsBtn').style.display = 'block';

                showMsg(
                    `âœ… å‡¦ç†å®Œäº†ï¼ (åº§æ¨™æŠ½å‡º)\n` +
                    `ğŸ“Œ æ¤œç´¢ç¯„å›²ã®BBox: çµŒåº¦ ${pinBBox[0].toFixed(5)}ï½${pinBBox[2].toFixed(5)}, ç·¯åº¦ ${pinBBox[1].toFixed(5)}ï½${pinBBox[3].toFixed(5)}\n` +
                    `ğŸ“ æŠ½å‡ºã«ä½¿ç”¨ã—ãŸãƒ”ãƒ³æ•°: ${pinFeatures.length}ä»¶\n` +
                    `ğŸ“ BBoxã¨äº¤å·®ã—ãŸãƒãƒªã‚´ãƒ³æ•°: ${matchedPolygons.length}ä»¶`
                );

            } catch (error) {
                console.error(error);
                showMsg('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: \n' + error.message || String(error), true);
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = "åº§æ¨™ã§æŠ½å‡ºã—ã¦å¯¾å¿œãƒ‡ãƒ¼ã‚¿ã‚’å‡ºåŠ›";
            }
        }

        // -----------------------------------------------------------
        // 3. ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–¢æ•°
        // -----------------------------------------------------------

        function downloadResult(type) {
            let jsonString, fileName;
            
            if (type === 'pins') {
                jsonString = matchedPinsString;
                fileName = "pin_search_area.geojson";
            } else if (type === 'polygons') {
                jsonString = matchedPolygonsString;
                fileName = "matched_polygons_bbox.geojson";
            } else {
                return;
            }

            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†
            const blob = new Blob([jsonString], { type: "application/geo+json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>