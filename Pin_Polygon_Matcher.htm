<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON ç©ºé–“æŠ½å‡º (è¿½åŠ èª­ã¿è¾¼ã¿å¯¾å¿œç‰ˆ)</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; margin: 20px; background-color: #f4f7f6; color: #333; }
        .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #d63384; text-align: center; border-bottom: 2px solid #d63384; padding-bottom: 10px; }
        
        .input-group { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background: #fafafa; }
        label { font-weight: bold; display: block; margin-bottom: 5px; }
        
        /* ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .file-list-area { margin-bottom: 20px; padding: 10px; border: 1px dashed #aaa; background: #fff; border-radius: 5px; min-height: 50px; }
        .file-list-header { font-size: 0.9em; color: #666; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        ul { list-style: none; padding: 0; margin: 0; }
        li { padding: 5px 10px; border-bottom: 1px solid #eee; font-size: 0.9em; display: flex; justify-content: space-between; }
        li:last-child { border-bottom: none; }
        .type-badge { font-size: 0.8em; padding: 2px 6px; border-radius: 4px; margin-left: 10px; }
        .badge-pin { background: #e0f7fa; color: #006064; }
        .badge-poly { background: #fff3e0; color: #e65100; }

        .settings-area { background-color: #fff3cd; border: 1px solid #ffeeba; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .checkbox-label { display: flex; align-items: center; cursor: pointer; font-weight: bold; color: #856404; }
        input[type="checkbox"] { transform: scale(1.5); margin-right: 10px; }

        .btn-group { display: flex; gap: 10px; margin-bottom: 15px; }
        button { flex: 1; padding: 15px; border: none; border-radius: 5px; font-size: 1.1em; cursor: pointer; font-weight: bold; }
        #runBtn { background: #007bff; color: white; flex: 2; }
        #runBtn:hover { background: #0056b3; }
        #runBtn:disabled { background: #ccc; cursor: not-allowed; }
        
        #clearBtn { background: #dc3545; color: white; flex: 1; }
        #clearBtn:hover { background: #a71d2a; }

        textarea { width: 100%; height: 200px; font-family: monospace; border: 1px solid #ccc; padding: 10px; }
        .status { margin-top: 15px; padding: 10px; border-radius: 5px; display: none; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ“ ãƒ”ãƒ³ãƒ»ãƒãƒªã‚´ãƒ³ è‡ªå‹•åˆ¤åˆ¥ï¼†æŠ½å‡º</h1>
    <p>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½•åº¦ã§ã‚‚è¿½åŠ ã§ãã¾ã™ã€‚ãƒªã‚¹ãƒˆã«æºœã‚ã¦ã‹ã‚‰ã€Œå‡¦ç†å®Ÿè¡Œã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚<br>
    ï¼ˆãƒ”ãƒ³ã¨ãƒãƒªã‚´ãƒ³ã¯è‡ªå‹•ã§æŒ¯ã‚Šåˆ†ã‘ã‚‰ã‚Œã¾ã™ï¼‰</p>

    <div class="input-group">
        <label>ğŸ“ GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ </label>
        <input type="file" id="fileInput" accept=".json,.geojson" multiple onchange="handleFiles(this.files)">
    </div>

    <div class="file-list-area">
        <div class="file-list-header">
            <span>ç¾åœ¨ã®èª­ã¿è¾¼ã¿ãƒªã‚¹ãƒˆ:</span>
            <span id="countDisplay">0 ãƒ•ã‚¡ã‚¤ãƒ« (ãƒ”ãƒ³: 0 / ãƒãƒªã‚´ãƒ³: 0)</span>
        </div>
        <ul id="fileList">
            <li style="color:#999; text-align:center;">ã¾ã ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“</li>
        </ul>
    </div>

    <div class="settings-area">
        <label class="checkbox-label">
            <input type="checkbox" id="strictMode">
            å³å¯†ãªå½¢çŠ¶åˆ¤å®šã‚’è¡Œã† (OFFæ¨å¥¨)
        </label>
        <p style="margin: 5px 0 0 30px; font-size: 0.9em; color: #666;">
            OFF (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ): å››è§’ã„ç¯„å›²(BBox)åˆ¤å®šã€‚é«˜é€Ÿã€‚<br>
            ON: æ­£ç¢ºãªå½¢çŠ¶åˆ¤å®šã€‚ãƒ‡ãƒ¼ã‚¿é‡ãŒå¤šã„ã¨é…ããªã‚Šã¾ã™ã€‚
        </p>
    </div>

    <div class="btn-group">
        <button id="clearBtn" onclick="clearAllData()">ğŸ—‘ï¸ ãƒªã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢</button>
        <button id="runBtn" onclick="runProcess()">â–¶ï¸ å‡¦ç†å®Ÿè¡Œ</button>
    </div>

    <div id="status" class="status"></div>

    <textarea id="output" readonly placeholder="çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™"></textarea>
    <button id="dlBtn" onclick="downloadResult()" style="display:none; width:100%; margin-top:10px; background:#28a745; color:white; padding:15px; border:none; border-radius:5px; font-weight:bold; cursor:pointer;">çµæœã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
</div>

<script>
    // ãƒ‡ãƒ¼ã‚¿ã‚’è“„ç©ã™ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    let storedFeatures = []; 
    let loadedFilesCount = 0;
    let resultJson = null;

    // ãƒ•ã‚¡ã‚¤ãƒ«èª­è¾¼å‡¦ç†ï¼ˆPromiseï¼‰
    const readFile = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => {
            try { resolve({ name: file.name, data: JSON.parse(e.target.result) }); }
            catch (err) { reject(err); }
        };
        reader.readAsText(file);
    });

    // GeoJSON FeatureæŠ½å‡º
    const getFeatures = (json) => {
        if (!json) return [];
        if (json.type === 'FeatureCollection' && Array.isArray(json.features)) return json.features;
        if (Array.isArray(json)) return json;
        if (json.type === 'Feature') return [json];
        return [];
    };

    // ãƒ•ã‚¡ã‚¤ãƒ«è¿½åŠ ãƒãƒ³ãƒ‰ãƒ©
    async function handleFiles(files) {
        if (!files || files.length === 0) return;

        const status = document.getElementById('status');
        status.style.display = 'none'; // å‰ã®ã‚¨ãƒ©ãƒ¼ãªã©ã‚’æ¶ˆã™

        for (let i = 0; i < files.length; i++) {
            try {
                const result = await readFile(files[i]);
                const features = getFeatures(result.data);
                
                // èª­ã¿è¾¼ã‚“ã Featureã«ãƒ•ã‚¡ã‚¤ãƒ«åã®æƒ…å ±ã‚’ä»˜åŠ ã—ã¦è“„ç©
                features.forEach(f => {
                    // Featureè‡ªä½“ã«æ‰‹ã‚’åŠ ãˆãšã€ç®¡ç†ç”¨é…åˆ—ã«è¿½åŠ 
                    storedFeatures.push(f);
                });
                
                addToFileListUI(result.name, features);
                
            } catch (e) {
                alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${files[i].name}ã€ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nå½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
                console.error(e);
            }
        }

        // å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†åº¦é¸ã¹ã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼‰
        document.getElementById('fileInput').value = '';
        updateCountDisplay();
    }

    // UIæ›´æ–°: ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã¸ã®è¿½åŠ 
    function addToFileListUI(fileName, features) {
        const list = document.getElementById('fileList');
        
        // åˆå›ã®ã¿ã€Œãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€ã‚’æ¶ˆã™
        if (loadedFilesCount === 0) list.innerHTML = '';

        // ç‰¹å¾´é‡ã®å†…è¨³ã‚’ç°¡æ˜“è¨ˆç®—
        let pCount = 0, polyCount = 0;
        features.forEach(f => {
            if (!f.geometry) return;
            const t = f.geometry.type;
            if (t === 'Point' || t === 'MultiPoint') pCount++;
            if (t === 'Polygon' || t === 'MultiPolygon') polyCount++;
        });

        const li = document.createElement('li');
        li.innerHTML = `
            <span>ğŸ“„ ${fileName}</span>
            <span>
                <span class="type-badge badge-pin">ğŸ“ ${pCount}</span>
                <span class="type-badge badge-poly">ğŸ—ºï¸ ${polyCount}</span>
            </span>
        `;
        list.appendChild(li);
        loadedFilesCount++;
    }

    // UIæ›´æ–°: ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤º
    function updateCountDisplay() {
        const pins = storedFeatures.filter(f => f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint')).length;
        const polys = storedFeatures.filter(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon')).length;
        document.getElementById('countDisplay').textContent = `${loadedFilesCount} ãƒ•ã‚¡ã‚¤ãƒ« (ãƒ‡ãƒ¼ã‚¿åˆè¨ˆ - ãƒ”ãƒ³: ${pins} / ãƒãƒªã‚´ãƒ³: ${polys})`;
    }

    // ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
    function clearAllData() {
        if(!confirm("èª­ã¿è¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) return;
        storedFeatures = [];
        loadedFilesCount = 0;
        resultJson = null;
        document.getElementById('fileList').innerHTML = '<li style="color:#999; text-align:center;">ã¾ã ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“</li>';
        document.getElementById('countDisplay').textContent = '0 ãƒ•ã‚¡ã‚¤ãƒ« (ãƒ”ãƒ³: 0 / ãƒãƒªã‚´ãƒ³: 0)';
        document.getElementById('output').value = '';
        document.getElementById('status').style.display = 'none';
        document.getElementById('dlBtn').style.display = 'none';
    }

    // --- ä»¥ä¸‹ã€è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå‰ã¨åŒã˜ï¼‰ ---

    const getBBox = (coords, type) => {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        const scan = (ring) => {
            for (const [x, y] of ring) {
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
            }
        };
        if (type === 'Polygon') scan(coords[0]);
        else if (type === 'MultiPolygon') coords.forEach(poly => scan(poly[0]));
        return { minX, maxX, minY, maxY };
    };

    const isPointInPoly = (pt, rings) => {
        const x = pt[0], y = pt[1];
        let inside = false;
        const ring = rings[0];
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            const xi = ring[i][0], yi = ring[i][1];
            const xj = ring[j][0], yj = ring[j][1];
            const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside; 
    };

    const isPointInGeometry = (pt, geometry) => {
        if (geometry.type === 'Polygon') return isPointInPoly(pt, geometry.coordinates);
        if (geometry.type === 'MultiPolygon') return geometry.coordinates.some(coords => isPointInPoly(pt, coords));
        return false;
    };

    async function runProcess() {
        const strictMode = document.getElementById('strictMode').checked;
        const status = document.getElementById('status');
        const btn = document.getElementById('runBtn');
        const dlBtn = document.getElementById('dlBtn');

        if (storedFeatures.length === 0) {
            alert("ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚\nãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚");
            return;
        }

        // è‡ªå‹•æŒ¯ã‚Šåˆ†ã‘
        const pins = storedFeatures.filter(f => f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint'));
        const polys = storedFeatures.filter(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));

        if (pins.length === 0) { alert("ã‚¨ãƒ©ãƒ¼: ãƒ”ãƒ³(Point)ã®ãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); return; }
        if (polys.length === 0) { alert("ã‚¨ãƒ©ãƒ¼: ãƒãƒªã‚´ãƒ³(Polygon)ã®ãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); return; }

        status.style.display = 'block';
        status.className = 'status';
        status.textContent = "å‡¦ç†ä¸­...";
        btn.disabled = true;

        await new Promise(r => setTimeout(r, 50)); // UIæç”»å¾…ã¡

        try {
            const results = [];
            const pinCoords = [];
            
            // ãƒ”ãƒ³åº§æ¨™ãƒªã‚¹ãƒˆåŒ–
            pins.forEach(p => {
                if(p.geometry.type === 'Point') pinCoords.push(p.geometry.coordinates);
                else if (p.geometry.type === 'MultiPoint') p.geometry.coordinates.forEach(c => pinCoords.push(c));
            });

            // åˆ¤å®šãƒ«ãƒ¼ãƒ—
            for (const poly of polys) {
                const bbox = getBBox(poly.geometry.coordinates, poly.geometry.type);
                let keep = false;
                
                for (const [px, py] of pinCoords) {
                    if (px >= bbox.minX && px <= bbox.maxX && py >= bbox.minY && py <= bbox.maxY) {
                        if (strictMode) {
                            if (isPointInGeometry([px, py], poly.geometry)) {
                                keep = true; break;
                            }
                        } else {
                            keep = true; break;
                        }
                    }
                }
                if (keep) results.push(poly);
            }

            const outGeoJSON = { type: "FeatureCollection", features: results };
            resultJson = JSON.stringify(outGeoJSON, null, 2);
            document.getElementById('output').value = resultJson;
            
            status.className = 'status success';
            status.innerHTML = `âœ… å®Œäº†! (${strictMode ? "å³å¯†" : "ç¯„å›²"})\nãƒ”ãƒ³: ${pins.length} / ãƒãƒªã‚´ãƒ³: ${polys.length} â†’ <b>æŠ½å‡º: ${results.length}ä»¶</b>`;
            dlBtn.style.display = 'inline-block';

        } catch (e) {
            console.error(e);
            status.className = 'status error';
            status.textContent = "ã‚¨ãƒ©ãƒ¼: " + e.message;
        } finally {
            btn.disabled = false;
        }
    }

    function downloadResult() {
        if (!resultJson) return;
        const blob = new Blob([resultJson], {type: "application/geo+json"});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'extracted_polygons.geojson';
        link.click();
    }
</script>

</body>
</html>