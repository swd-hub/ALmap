<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON ç©ºé–“æŠ½å‡ºãƒ„ãƒ¼ãƒ« (ä¸€æ‹¬å…¥åŠ›ç‰ˆ)</title>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            margin: 20px;
            background-color: #f0f2f5;
            color: #333;
        }
        h1 {
            color: #17a2b8;
            text-align: center;
            border-bottom: 3px solid #17a2b8;
            padding-bottom: 10px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .input-section {
            margin-bottom: 25px;
        }
        .input-group {
            padding: 20px;
            border: 2px dashed #17a2b8;
            border-radius: 8px;
            background-color: #f8f9fa;
            text-align: center;
        }
        h2 {
            font-size: 1.2em;
            color: #17a2b8;
            margin-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="file"] {
            width: 80%;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            display: block;
            width: 100%;
            margin-top: 20px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .output-section {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }
        .output-box {
            flex: 1;
        }
        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            background-color: #f9f9f9;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        .message {
            margin-top: 15px;
            padding: 15px;
            border-radius: 4px;
            display: none;
            white-space: pre-wrap;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .file-list-info {
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>GeoJSON ç©ºé–“æŠ½å‡ºãƒ„ãƒ¼ãƒ« (ä¸€æ‹¬è‡ªå‹•æŒ¯ã‚Šåˆ†ã‘)</h1>
        <p>ğŸ“‚ è¤‡æ•°ã®GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã¾ã¨ã‚ã¦é¸æŠã—ã¦ãã ã•ã„ã€‚<br>
           ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒè‡ªå‹•çš„ã«<b>ã€ŒğŸ“ãƒ”ãƒ³ (Point)ã€</b>ã¨<b>ã€ŒğŸ—ºï¸ãƒãƒªã‚´ãƒ³ (Polygon)ã€</b>ã‚’åˆ¤åˆ¥ã—ã€<br>
           ãƒ”ãƒ³ã®å…¨ç¯„å›² (BBox) ã«é‡ãªã‚‹ãƒãƒªã‚´ãƒ³ã®ã¿ã‚’æŠ½å‡ºã—ã¾ã™ã€‚</p>

        <div class="input-section">
            
            <div class="input-group">
                <h2>ğŸ“‚ ãƒ•ã‚¡ã‚¤ãƒ«ä¸€æ‹¬ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h2>
                <label for="mixedFiles">ãƒ”ãƒ³ã¨ãƒãƒªã‚´ãƒ³ã®ãƒ•ã‚¡ã‚¤ãƒ« (è¤‡æ•°é¸æŠå¯):</label>
                <input type="file" id="mixedFiles" accept=".json,.geojson" multiple onchange="updateFileInfo()">
                <div id="fileInfo" class="file-list-info">ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“</div>
            </div>
            
        </div>
        
        <button onclick="processMixedFiles()" id="processBtn">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§å‡¦ç†é–‹å§‹</button>
        <div id="statusMessage" class="message"></div>
        
        <div class="output-section">
            <div class="output-box">
                <h2>å‡ºåŠ› 1: æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ³ (ç¯„å›²å®šç¾©ç”¨)</h2>
                <textarea id="matchedPinsOutput" readonly placeholder="Pointãƒ‡ãƒ¼ã‚¿ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™..."></textarea>
                <button onclick="downloadResult('pins')" id="downloadPinsBtn" style="display:none; background-color: #28a745;">ãƒ”ãƒ³ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            </div>
            <div class="output-box">
                <h2>å‡ºåŠ› 2: æŠ½å‡ºã•ã‚ŒãŸãƒãƒªã‚´ãƒ³</h2>
                <textarea id="matchedPolygonsOutput" readonly placeholder="æŠ½å‡ºã•ã‚ŒãŸPolygonãƒ‡ãƒ¼ã‚¿ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™..."></textarea>
                <button onclick="downloadResult('polygons')" id="downloadPolygonsBtn" style="display:none; background-color: #28a745;">ãƒãƒªã‚´ãƒ³ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            </div>
        </div>
    </div>

    <script>
        let matchedPinsString = "";
        let matchedPolygonsString = "";

        // -----------------------------------------------------------
        // 1. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        // -----------------------------------------------------------

        // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠæ™‚ã«ä»¶æ•°ã‚’è¡¨ç¤ºã™ã‚‹UIç”¨é–¢æ•°
        function updateFileInfo() {
            const input = document.getElementById('mixedFiles');
            const infoDiv = document.getElementById('fileInfo');
            if (input.files.length > 0) {
                infoDiv.textContent = `${input.files.length} å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™ã€‚`;
            } else {
                infoDiv.textContent = "ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“";
            }
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’éåŒæœŸã§èª­ã¿è¾¼ã‚€æ±ç”¨é–¢æ•°
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    try {
                        const parsed = JSON.parse(e.target.result);
                        if (typeof parsed !== 'object' || parsed === null) {
                            reject(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã®å†…å®¹ãŒä¸æ­£ã§ã™ã€‚`);
                            return;
                        }
                        resolve({ fileName: file.name, data: parsed });
                    } catch (err) {
                        reject(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã¯æœ‰åŠ¹ãªGeoJSONã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`);
                    }
                };
                reader.onerror = () => reject(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`);
                reader.readAsText(file);
            });
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºé–¢æ•°
        function showMsg(text, isError = false) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = text;
            statusDiv.className = isError ? "message error" : "message success";
            statusDiv.style.display = "block";
        }

        // BBoxè¨ˆç®— (Pointç”¨)
        function calculatePinBBox(pinFeatures) {
            let minLng = Infinity, maxLng = -Infinity;
            let minLat = Infinity, maxLat = -Infinity;

            pinFeatures.forEach(f => {
                if (f.geometry && f.geometry.coordinates) {
                    const [lng, lat] = f.geometry.coordinates;
                    minLng = Math.min(minLng, lng);
                    maxLng = Math.max(maxLng, lng);
                    minLat = Math.min(minLat, lat);
                    maxLat = Math.max(maxLat, lat);
                }
            });

            if (minLng === Infinity) return null;
            return [minLng, minLat, maxLng, maxLat];
        }

        // BBoxè¨ˆç®— (Polygonç”¨)
        function getFeatureBBox(feature) {
            let minLng = Infinity, maxLng = -Infinity;
            let minLat = Infinity, maxLat = -Infinity;
            
            if (!feature.geometry || !feature.geometry.coordinates) return null;

            const extractCoords = (coords) => {
                if (typeof coords[0][0] === 'number') { 
                    coords.forEach(([lng, lat]) => {
                        minLng = Math.min(minLng, lng);
                        maxLng = Math.max(maxLng, lng);
                        minLat = Math.min(minLat, lat);
                        maxLat = Math.max(maxLat, lat);
                    });
                } else {
                    coords.forEach(ring => extractCoords(ring));
                }
            };
            
            extractCoords(feature.geometry.coordinates);

            if (minLng === Infinity) return null;
            return [minLng, minLat, maxLng, maxLat];
        }

        // BBoxäº¤å·®åˆ¤å®š
        function checkBBoxIntersection(bbox1, bbox2) {
            const [minLng1, minLat1, maxLng1, maxLat1] = bbox1;
            const [minLng2, minLat2, maxLng2, maxLat2] = bbox2;

            return maxLng1 >= minLng2 && 
                   minLng1 <= maxLng2 &&
                   maxLat1 >= minLat2 &&
                   minLat1 <= maxLat2;
        }

        // -----------------------------------------------------------
        // 2. ãƒ¡ã‚¤ãƒ³å‡¦ç†é–¢æ•° (ä¸€æ‹¬èª­ã¿è¾¼ã¿ & è‡ªå‹•æŒ¯ã‚Šåˆ†ã‘)
        // -----------------------------------------------------------

        async function processMixedFiles() {
            const fileInput = document.getElementById('mixedFiles');
            const processBtn = document.getElementById('processBtn');

            // åˆæœŸåŒ–
            document.getElementById('matchedPinsOutput').value = '';
            document.getElementById('matchedPolygonsOutput').value = '';
            document.getElementById('downloadPinsBtn').style.display = 'none';
            document.getElementById('downloadPolygonsBtn').style.display = 'none';
            document.getElementById('statusMessage').style.display = 'none';

            if (fileInput.files.length === 0) {
                showMsg('ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å°‘ãªãã¨ã‚‚1ã¤ã®GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', true);
                return;
            }

            processBtn.disabled = true;
            processBtn.textContent = "å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€åˆ†é¡ãƒ»å‡¦ç†ä¸­...";

            try {
                // 1. ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸¦åˆ—ã§èª­ã¿è¾¼ã‚€
                const filePromises = Array.from(fileInput.files).map(file => readFileAsync(file));
                const loadedFiles = await Promise.all(filePromises);

                // 2. ãƒ‡ãƒ¼ã‚¿ã‚’Featureå˜ä½ã«åˆ†è§£ã—ã€Pointã¨Polygonã«æŒ¯ã‚Šåˆ†ã‘ã‚‹
                let allPinFeatures = [];
                let allPolyFeatures = [];
                let errorMessages = [];

                loadedFiles.forEach(fileObj => {
                    const data = fileObj.data;
                    // FeatureCollectionã‹å˜ä¸€Featureã‹åˆ¤å®šã—ã¦é…åˆ—åŒ–
                    const features = (data.type === "FeatureCollection" && Array.isArray(data.features)) 
                                    ? data.features 
                                    : (data.type === "Feature" ? [data] : []);

                    if (features.length === 0) {
                        // GeoJSONã ãŒFeatureãŒãªã„å ´åˆï¼ˆä¾‹: ç©ºã®FeatureCollectionï¼‰
                        return; 
                    }

                    features.forEach(f => {
                        if (!f.geometry || !f.geometry.type) return;

                        const type = f.geometry.type;
                        if (type === 'Point') {
                            allPinFeatures.push(f);
                        } else if (type === 'Polygon' || type === 'MultiPolygon') {
                            allPolyFeatures.push(f);
                        }
                        // LineStringãªã©ã¯ã“ã“ã§ã¯ç„¡è¦–ã•ã‚Œã¾ã™
                    });
                });

                // 3. ãƒ‡ãƒ¼ã‚¿å­˜åœ¨ãƒã‚§ãƒƒã‚¯
                if (allPinFeatures.length === 0) {
                    throw new Error("èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸­ã«ã€ŒPoint (ãƒ”ãƒ³)ã€ãƒ‡ãƒ¼ã‚¿ãŒ1ã¤ã‚‚è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\næ¤œç´¢ç¯„å›²ã‚’æ±ºã‚ã‚‹ãŸã‚ã®ãƒ”ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚ã¦ãã ã•ã„ã€‚");
                }
                if (allPolyFeatures.length === 0) {
                    throw new Error("èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸­ã«ã€ŒPolygon (ãƒãƒªã‚´ãƒ³)ã€ãƒ‡ãƒ¼ã‚¿ãŒ1ã¤ã‚‚è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\næŠ½å‡ºå¯¾è±¡ã¨ãªã‚‹ãƒãƒªã‚´ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚ã¦ãã ã•ã„ã€‚");
                }

                // 4. ãƒ”ãƒ³ã®BBoxï¼ˆæ¤œç´¢ç¯„å›²ï¼‰ã‚’è¨ˆç®—
                const pinBBox = calculatePinBBox(allPinFeatures);
                if (!pinBBox) {
                      throw new Error("ãƒ”ãƒ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æœ‰åŠ¹ãªåº§æ¨™ç¯„å›²ã‚’è¨ˆç®—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚");
                }

                // 5. ãƒãƒªã‚´ãƒ³ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                const matchedPolygons = [];
                allPolyFeatures.forEach(poly => {
                    const polyBBox = getFeatureBBox(poly);
                    if (polyBBox && checkBBoxIntersection(pinBBox, polyBBox)) {
                        matchedPolygons.push(poly);
                    }
                });

                // 6. çµæœã®å‡ºåŠ›
                const resultPins = { type: "FeatureCollection", features: allPinFeatures };
                const resultPolygons = { type: "FeatureCollection", features: matchedPolygons };

                matchedPinsString = JSON.stringify(resultPins, null, 2);
                matchedPolygonsString = JSON.stringify(resultPolygons, null, 2);
                
                document.getElementById('matchedPinsOutput').value = matchedPinsString;
                document.getElementById('matchedPolygonsOutput').value = matchedPolygonsString;
                
                document.getElementById('downloadPinsBtn').style.display = 'block';
                document.getElementById('downloadPolygonsBtn').style.display = 'block';

                showMsg(
                    `âœ… å‡¦ç†å®Œäº†ï¼ (ä¸€æ‹¬åˆ†é¡æˆåŠŸ)\n` +
                    `ğŸ“‚ èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${loadedFiles.length}\n` +
                    `ğŸ“Œ æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ³: ${allPinFeatures.length}ä»¶ (BBoxæ¤œç´¢ç¯„å›²ã‚’ä½œæˆ)\n` +
                    `ğŸ—ºï¸ æ¤œå‡ºã•ã‚ŒãŸãƒãƒªã‚´ãƒ³: ${allPolyFeatures.length}ä»¶\n` +
                    `----------------------------------------\n` +
                    `ğŸ“ æŠ½å‡ºçµæœ (BBoxå†…): ${matchedPolygons.length}ä»¶ã®ãƒãƒªã‚´ãƒ³ãŒãƒ’ãƒƒãƒˆã—ã¾ã—ãŸã€‚`
                );

            } catch (error) {
                console.error(error);
                showMsg('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: \n' + (error.message || String(error)), true);
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§å‡¦ç†é–‹å§‹";
            }
        }

        // -----------------------------------------------------------
        // 3. ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–¢æ•°
        // -----------------------------------------------------------

        function downloadResult(type) {
            let jsonString, fileName;
            
            if (type === 'pins') {
                jsonString = matchedPinsString;
                fileName = "extracted_pins.geojson";
            } else if (type === 'polygons') {
                jsonString = matchedPolygonsString;
                fileName = "filtered_polygons.geojson";
            } else {
                return;
            }

            const blob = new Blob([jsonString], { type: "application/geo+json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>