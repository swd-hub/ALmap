<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ğŸ—ºï¸ GeoJSON åœ°åŸŸåˆ¥æŠ½å‡ºï¼ˆBBoxç©ºé–“ç…§åˆï¼‰ï¼†ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ„ãƒ¼ãƒ«</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background-color: #f0f2f5; }
        h1 { color: #17a2b8; border-bottom: 3px solid #17a2b8; padding-bottom: 10px; margin-bottom: 20px; text-align: center; }
        h3 { color: #34495e; border-bottom: 2px solid #bdc3c7; padding-bottom: 5px; margin-top: 20px; }
        #file-input { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; background-color: #ecf0f1; border-radius: 5px; }
        #address-selection { border: 1px solid #3498db; padding: 15px; margin-bottom: 20px; background-color: #eaf6ff; border-radius: 5px; }
        .radio-container { max-height: 250px; overflow-y: auto; padding: 10px; border: 1px dashed #a8c1d9; }
        .radio-container div { margin-bottom: 5px; }
        input[type="radio"] { margin-right: 5px; }
        /* ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
        table { width: 100%; border-collapse: collapse; margin-top: 10px; background-color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: left; font-size: 14px; }
        th { background-color: #17a2b8; color: white; position: sticky; top: 0; }
        /* ãƒœã‚¿ãƒ³ */
        button { padding: 10px 15px; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        button:hover { filter: brightness(0.9); }
        button:disabled { background-color: #ccc !important; cursor: not-allowed; }
        .process-button { background-color: #2ecc71; margin-left: 10px; }
        .download-button { margin-top: 10px; display: inline-block; width: auto; }
        #statusMessage { margin-top: 10px; padding: 10px; border-radius: 5px; white-space: pre-wrap;}
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ—ºï¸ GeoJSON åœ°åŸŸåˆ¥æŠ½å‡ºï¼ˆBBoxç©ºé–“ç…§åˆï¼‰ï¼†ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ„ãƒ¼ãƒ«</h1>
        <p>GeoJSONãƒ•ã‚¡ã‚¤ãƒ« (`.geojson`, `.json`) ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã€åœ°åŸŸã‚’é¸æŠã™ã‚‹ã“ã¨ã§ã€**é¸æŠã—ãŸåœ°åŸŸã®ãƒ”ãƒ³ã®åº§æ¨™ç¯„å›² (BBox)** ã¨**äº¤å·®ã™ã‚‹ãƒãƒªã‚´ãƒ³**ã‚’æŠ½å‡ºãƒ»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚</p>

        <div id="file-input">
            <input type="file" id="geojsonFileInput" accept=".geojson,.json" multiple>
            <button onclick="processFiles()" id="processBtn" class="process-button">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç† (é‡è¤‡å‰Šé™¤ãƒ»åœ°åŸŸã‚°ãƒ«ãƒ¼ãƒ”ãƒ³ã‚°)</button>
            <div id="statusMessage" style="display:none;"></div>
        </div>

        <div id="settings-area">
            <h3>ğŸ—ºï¸ ç©ºé–“ç…§åˆã®è¨­å®š (â€»ç¾åœ¨ã¯å±æ€§ã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã›ã‚“)</h3>
            <p>ç¾åœ¨ã®æŠ½å‡ºãƒ­ã‚¸ãƒƒã‚¯ã¯ã€é¸æŠåœ°åŸŸã®ãƒ”ãƒ³ã®åº§æ¨™ã‹ã‚‰è¨ˆç®—ã•ã‚Œã‚‹**å››è§’å½¢ (BBox)** ã¨ã€ãƒãƒªã‚´ãƒ³ã®BBoxã®**äº¤å·®åˆ¤å®š**ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚ã“ã®ãŸã‚ã€ä»¥ä¸‹ã®ã‚­ãƒ¼è¨­å®šã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚</p>
            <label for="pinKey">ğŸ“ ãƒ”ãƒ³ãƒ‡ãƒ¼ã‚¿ã®ç…§åˆã‚­ãƒ¼ (ç„¡è¦–):</label>
            <input type="text" id="pinKey" placeholder="Pin Key Name" value="id" style="width: 150px;" disabled>
            <label for="polyKey" style="margin-left: 20px;">ğŸ“ ãƒãƒªã‚´ãƒ³ãƒ‡ãƒ¼ã‚¿ã®ç…§åˆã‚­ãƒ¼ (ç„¡è¦–):</label>
            <input type="text" id="polyKey" placeholder="Polygon Key Name" value="id" style="width: 150px;" disabled>
        </div>

        <div id="address-selection">
            <h3>åœ°åŸŸé¸æŠ (åŠ å·¥æ¸ˆã¿ä½æ‰€)</h3>
            <p>â€»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†å¾Œã€ã“ã“ã«åœ°åŸŸãƒªã‚¹ãƒˆãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>
            <div id="radioButtonsContainer" class="radio-container">
                <p>ãƒ‡ãƒ¼ã‚¿ãªã—</p>
            </div>
        </div>

        <div id="result-area">
            <h3>æŠ½å‡ºã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿</h3>
            <p id="selectedAddressText">é¸æŠã•ã‚ŒãŸåœ°åŸŸï¼šãªã—</p>
            
            <div id="downloadButtonContainer" style="display:none; margin-bottom: 10px;">
                <button class="download-button" onclick="downloadPinGeoJson()" disabled id="downloadPinButton" style="background-color: #f39c12;">
                    ğŸ“ ãƒ”ãƒ³ 0 ä»¶ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                </button>
                <button class="download-button" onclick="downloadPolyGeoJson()" disabled id="downloadPolyButton" style="background-color: #3498db;">
                    ğŸ“ ç…§åˆãƒãƒªã‚´ãƒ³ 0 ä»¶ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                </button>
            </div>
            
            <div style="max-height: 400px; overflow-y: auto;">
                <table id="dataTable">
                    </table>
            </div>
        </div>
    </div>

    <script>
        // -----------------------------------------------------------
        // 1. ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨åˆæœŸè¨­å®š
        // -----------------------------------------------------------

        let allUniquePinFeatures = []; // å…¨ãƒ¦ãƒ‹ãƒ¼ã‚¯ãƒ”ãƒ³
        let allUniquePolyFeatures = []; // å…¨ãƒ¦ãƒ‹ãƒ¼ã‚¯ãƒãƒªã‚´ãƒ³
        let groupedFeatures = new Map(); // åœ°åŸŸã”ã¨ã®ãƒ”ãƒ³ã®ã‚°ãƒ«ãƒ¼ãƒ—
        let currentSelectedGroup = { pin: [], poly: [] }; // é¸æŠåœ°åŸŸã®ãƒ”ãƒ³ã¨ã€ãã‚Œã«å¯¾å¿œã™ã‚‹ãƒãƒªã‚´ãƒ³

        // -----------------------------------------------------------
        // 2. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        // -----------------------------------------------------------

        function cleanAddressString(address) {
            // ä½æ‰€æ–‡å­—åˆ—ã®ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯
            let cleaned = address.replace(/\s*\(.*?\)\s*/g, ''); 
            cleaned = cleaned.replace(/\s*ï¼ˆ.*?ï¼‰\s*/g, '');
            cleaned = cleaned.trim();
            // ä¸ç•ªåœ°ç­‰ã®æ•°å­—ã¨ä¸€éƒ¨è¨˜å·ã‚’é™¤å»
            cleaned = cleaned.replace(/(?:[0-9ï¼-ï¼™ãƒ¼â€•-]|ä¸ç›®|ç•ª|å·|åœ°å‰²|ç·š|ã®|å‰²|ç”²|ä¹™|ä¸™|ä¸)+$/g, '');
            return cleaned.trim();
        }

        function consistentStringify(obj) {
            // ãƒ•ã‚£ãƒ¼ãƒãƒ£ã®é‡è¤‡åˆ¤å®šç”¨é–¢æ•°
            if (obj === null || typeof obj !== 'object') {
                return JSON.stringify(obj);
            }
            if (Array.isArray(obj)) {
                return '[' + obj.map(item => consistentStringify(item)).join(',') + ']';
            }
            const sortedKeys = Object.keys(obj).sort();
            const parts = sortedKeys.map(key => {
                return JSON.stringify(key) + ':' + consistentStringify(obj[key]);
            });
            return '{' + parts.join(',') + '}';
        }

        function getUniqueFeatures(features) {
            // ãƒ•ã‚£ãƒ¼ãƒãƒ£ã®é‡è¤‡ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°
            const uniqueFeatures = [];
            const seenSignatures = new Set();
            features.forEach(feature => {
                if (feature.geometry) {
                    const geomStr = consistentStringify(feature.geometry);
                    const propStr = consistentStringify(feature.properties);
                    const signature = `${geomStr}|${propStr}`;
                    if (!seenSignatures.has(signature)) {
                        seenSignatures.add(signature);
                        uniqueFeatures.push(feature);
                    }
                }
            });
            return uniqueFeatures;
        }

        async function loadAndSeparateFeatures(files) {
            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€Pinã¨Polygonã«åˆ†é›¢ã™ã‚‹é–¢æ•°
            const featuresPin = [];
            const featuresPoly = [];
            const filePromises = files.map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => {
                        try {
                            const json = JSON.parse(e.target.result);
                            let features = [];
                            if (json.type === "FeatureCollection" && Array.isArray(json.features)) {
                                features = json.features;
                            } else if (json.type === "Feature") {
                                features.push(json);
                            }
                            
                            features.forEach(f => {
                                if (f.geometry && f.geometry.type === "Point") {
                                    featuresPin.push(f);
                                } else if (f.geometry) {
                                    // Pointä»¥å¤–ã®ã™ã¹ã¦ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’Polygon/Lineã¨ã—ã¦æ‰±ã†
                                    featuresPoly.push(f);
                                }
                            });
                            resolve();
                        } catch (err) {
                            reject(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã¯æœ‰åŠ¹ãªGeoJSONã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`);
                        }
                    };
                    reader.onerror = () => reject(`ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`);
                    reader.readAsText(file);
                });
            });

            await Promise.all(filePromises);
            return { pin: featuresPin, poly: featuresPoly };
        }

        /**
         * [NEW] è¤‡æ•°ã®Pointãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‹ã‚‰ã€ãã‚Œã‚‰ã‚’åŒ…å«ã™ã‚‹BBox [minLng, minLat, maxLng, maxLat] ã‚’è¨ˆç®—ã™ã‚‹ã€‚
         */
        function calculatePinBBox(pinFeatures) {
            let minLng = Infinity, maxLng = -Infinity;
            let minLat = Infinity, maxLat = -Infinity;

            pinFeatures.forEach(f => {
                if (f.geometry && f.geometry.type === 'Point' && f.geometry.coordinates) {
                    const [lng, lat] = f.geometry.coordinates;
                    minLng = Math.min(minLng, lng);
                    maxLng = Math.max(maxLng, lng);
                    minLat = Math.min(minLat, lat);
                    maxLat = Math.max(maxLat, lat);
                }
            });

            if (minLng === Infinity) return null;
            return [minLng, minLat, maxLng, maxLat];
        }

        /**
         * [NEW] Polygon/MultiPolygonãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‹ã‚‰ã€ãã®ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‚’åŒ…å«ã™ã‚‹BBoxã‚’è¨ˆç®—ã™ã‚‹ã€‚
         * BBox: [minLng, minLat, maxLng, maxLat]
         */
        function getFeatureBBox(feature) {
            let minLng = Infinity, maxLng = -Infinity;
            let minLat = Infinity, maxLat = -Infinity;
            
            if (!feature.geometry || !feature.geometry.coordinates) return null;

            const coords = feature.geometry.coordinates;

            const extractCoords = (c) => {
                if (Array.isArray(c) && c.length >= 2 && typeof c[0] === 'number' && typeof c[1] === 'number') {
                    // Found a coordinate pair [lng, lat]
                    minLng = Math.min(minLng, c[0]);
                    maxLng = Math.max(maxLng, c[0]);
                    minLat = Math.min(minLat, c[1]);
                    maxLat = Math.max(maxLat, c[1]);
                } else if (Array.isArray(c)) {
                    // Recurse into array
                    c.forEach(extractCoords);
                }
            };

            extractCoords(coords);

            if (minLng === Infinity) return null;
            return [minLng, minLat, maxLng, maxLat];
        }

        /**
         * [NEW] 2ã¤ã®BBoxãŒäº¤å·®ã™ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã€‚
         * bbox: [minLng, minLat, maxLng, maxLat]
         */
        function checkBBoxIntersection(bbox1, bbox2) {
            const [minLng1, minLat1, maxLng1, maxLat1] = bbox1;
            const [minLng2, minLat2, maxLng2, maxLat2] = bbox2;

            return maxLng1 >= minLng2 && 
                   minLng1 <= maxLng2 &&
                   maxLat1 >= minLat2 &&
                   minLat1 <= maxLat2;
        }


        // -----------------------------------------------------------
        // 3. ãƒ¡ã‚¤ãƒ³å‡¦ç†é–¢æ•°
        // -----------------------------------------------------------

        async function processFiles() {
            const input = document.getElementById('geojsonFileInput');
            const files = input.files;
            const statusDiv = document.getElementById('statusMessage');
            const processBtn = document.getElementById('processBtn');

            if (files.length === 0) {
                alert('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸€ã¤ä»¥ä¸Šé¸æŠã—ã¦ãã ã•ã„ã€‚');
                return;
            }

            // åˆæœŸåŒ–
            allUniquePinFeatures = [];
            allUniquePolyFeatures = [];
            groupedFeatures.clear();
            currentSelectedGroup = { pin: [], poly: [] };
            document.getElementById('radioButtonsContainer').innerHTML = '<p>ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</p>';
            document.getElementById('downloadButtonContainer').style.display = 'none';
            displayFilteredData(null);
            statusDiv.style.display = 'block';
            statusDiv.className = "message";
            statusDiv.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€ãƒ•ã‚£ãƒ¼ãƒãƒ£ã‚’åˆ†é›¢ã—ã¦ã„ã¾ã™...';
            processBtn.disabled = true;
            processBtn.textContent = "å‡¦ç†ä¸­...";


            try {
                // A. å…¨Featureã®èª­ã¿è¾¼ã¿ã¨ãƒ”ãƒ³/ãƒãƒªã‚´ãƒ³ã¸ã®åˆ†é›¢
                const separatedFeatures = await loadAndSeparateFeatures(Array.from(files));
                
                // B. é‡è¤‡å‰Šé™¤
                allUniquePinFeatures = getUniqueFeatures(separatedFeatures.pin);
                allUniquePolyFeatures = getUniqueFeatures(separatedFeatures.poly); // å…¨ãƒãƒªã‚´ãƒ³ãƒ‡ãƒ¼ã‚¿ã¯ã“ã“ã§ä¿æŒ

                // C. ä½æ‰€ã®åŠ å·¥ã¨ã‚°ãƒ«ãƒ¼ãƒ”ãƒ³ã‚° (Pinã®ã¿ã‚’ä½æ‰€ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–)
                allUniquePinFeatures.forEach(feature => {
                    // Pinãƒ‡ãƒ¼ã‚¿ã« 'Address' ã¨ã„ã†å±æ€§ãŒã‚ã‚‹ã“ã¨ã‚’å‰æã¨ã™ã‚‹
                    const address = feature.properties ? feature.properties.Address : null; 
                    
                    if (address && address !== "") { 
                        const cleanAddress = cleanAddressString(address);
                        
                        if (!groupedFeatures.has(cleanAddress)) {
                            groupedFeatures.set(cleanAddress, { pin: [], poly: [] });
                        }
                        
                        const group = groupedFeatures.get(cleanAddress);
                        group.pin.push(feature);
                    }
                });
                
                // D. ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã®ç”Ÿæˆ
                const uniqueAddresses = Array.from(groupedFeatures.keys());
                renderRadioButtons(uniqueAddresses);
                
                // æœ€åˆã®ä½æ‰€ã‚’è‡ªå‹•é¸æŠã—ã¦è¡¨ç¤º
                if (uniqueAddresses.length > 0) {
                     const firstAddress = uniqueAddresses[0];
                     displayFilteredData(firstAddress);
                     const firstRadio = document.querySelector('.radio-container input[type="radio"]');
                     if(firstRadio) firstRadio.checked = true;
                } else {
                     displayFilteredData(null);
                }
                
                // å‡¦ç†çµæœã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
                statusDiv.textContent = `âœ… å‡¦ç†å®Œäº†: \n` + 
                    `ğŸ“ ãƒ”ãƒ³(Point): ${separatedFeatures.pin.length}ä»¶ â†’ ãƒ¦ãƒ‹ãƒ¼ã‚¯ ${allUniquePinFeatures.length}ä»¶\n` +
                    `ğŸ“ ãƒãƒªã‚´ãƒ³ä»–: ${separatedFeatures.poly.length}ä»¶ â†’ ãƒ¦ãƒ‹ãƒ¼ã‚¯ ${allUniquePolyFeatures.length}ä»¶\n` +
                    `ğŸ“ åœ°åŸŸåˆ¥ã‚°ãƒ«ãƒ¼ãƒ—: ${uniqueAddresses.length}ä»¶`;
                statusDiv.className = "message success";


            } catch (error) {
                console.error('ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
                statusDiv.textContent = 'âŒ ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚è©³ç´°ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ç¢ºèªã—ã¦ãã ã•ã„ã€‚ã‚¨ãƒ©ãƒ¼: ' + error;
                statusDiv.className = "message error";
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç† (é‡è¤‡å‰Šé™¤ãƒ»åœ°åŸŸã‚°ãƒ«ãƒ¼ãƒ”ãƒ³ã‚°)";
            }
        }


        // -----------------------------------------------------------
        // 4. è¡¨ç¤º/ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–¢é€£é–¢æ•°
        // -----------------------------------------------------------

        function renderRadioButtons(addresses) {
            const container = document.getElementById('radioButtonsContainer');
            container.innerHTML = ''; 

            if (addresses.length === 0) {
                container.innerHTML = '<p>ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªåœ°åŸŸãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã€ŒAddressã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>';
                return;
            }

            addresses.forEach((address, index) => {
                const group = groupedFeatures.get(address);
                const pinCount = group.pin.length;
                
                const div = document.createElement('div');
                const radioId = `addr_${index}`;
                
                div.innerHTML = `
                    <input type="radio" id="${radioId}" name="cleanAddress" value="${address}" 
                            onclick="displayFilteredData(this.value)">
                    <label for="${radioId}">
                        ${address} (ãƒ”ãƒ³ ${pinCount} ä»¶)
                    </label>
                `;
                container.appendChild(div);
            });
        }

        function displayFilteredData(selectedAddress) {
            const table = document.getElementById('dataTable');
            const selectedAddressText = document.getElementById('selectedAddressText');
            table.innerHTML = ''; 
            
            if (!selectedAddress) {
                selectedAddressText.textContent = 'é¸æŠã•ã‚ŒãŸåœ°åŸŸï¼šãªã—';
                document.getElementById('downloadButtonContainer').style.display = 'none';
                table.innerHTML = '<thead><tr><th>ãƒ‡ãƒ¼ã‚¿ãªã—</th></tr></thead><tbody></tbody>';
                return;
            }

            // âš ï¸ ATTRIBUTE MATCHING KEYS ARE IGNORED FOR MATCHING LOGIC
            // const PIN_MATCH_KEY = document.getElementById('pinKey').value.trim();
            // const POLY_MATCH_KEY = document.getElementById('polyKey').value.trim();

            const group = groupedFeatures.get(selectedAddress);
            
            // 1. é¸æŠã•ã‚ŒãŸåœ°åŸŸã®ãƒ”ãƒ³ãƒ‡ãƒ¼ã‚¿ï¼ˆåœ°åŸŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ¸ˆï¼‰ã‚’å–å¾—
            const selectedPins = group.pin;

            // 2. ğŸ’¡ (NEW) é¸æŠã•ã‚ŒãŸãƒ”ãƒ³ãƒ•ã‚£ãƒ¼ãƒãƒ£ã‹ã‚‰BBoxï¼ˆæ¤œç´¢ç¯„å›²ï¼‰ã‚’è¨ˆç®—
            const pinBBox = calculatePinBBox(selectedPins); 

            let matchedPolygons = [];
            let bboxStatusMessage = "";

            if (!pinBBox) {
                // Pinã‹ã‚‰æœ‰åŠ¹ãªåº§æ¨™ã‚’æŠ½å‡ºã§ããªã‹ã£ãŸå ´åˆ
                bboxStatusMessage = `âš ï¸ ãƒ”ãƒ³ ${selectedPins.length} ä»¶ã‹ã‚‰æœ‰åŠ¹ãªåº§æ¨™ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚`;
                // MatchedPolygonsã¯ç©ºã®ã¾ã¾
            } else {
                // 3. ğŸ’¡ (NEW) å…¨ãƒãƒªã‚´ãƒ³ãƒ•ã‚£ãƒ¼ãƒãƒ£ã‹ã‚‰ã€ãƒ”ãƒ³BBoxã¨äº¤å·®ã™ã‚‹ã‚‚ã®ã®ã¿ã‚’æŠ½å‡º (ç©ºé–“ç…§åˆãƒ­ã‚¸ãƒƒã‚¯)
                matchedPolygons = allUniquePolyFeatures.filter(f => {
                    const polyBBox = getFeatureBBox(f);
                    
                    // ãƒãƒªã‚´ãƒ³ã«æœ‰åŠ¹ãªBBoxãŒã‚ã‚Šã€ã‹ã¤ãƒ”ãƒ³ã®BBoxã¨äº¤å·®ã™ã‚‹å ´åˆã«æŠ½å‡º
                    return polyBBox && checkBBoxIntersection(pinBBox, polyBBox);
                });
                
                bboxStatusMessage = `ğŸ—ºï¸ æ¤œç´¢ BBox: çµŒåº¦ ${pinBBox[0].toFixed(5)}ï½${pinBBox[2].toFixed(5)}, ç·¯åº¦ ${pinBBox[1].toFixed(5)}ï½${pinBBox[3].toFixed(5)}`;
            }

            // 4. ã‚°ãƒ«ãƒ¼ãƒ—å¤‰æ•°ã«çµæœã‚’æ ¼ç´
            currentSelectedGroup.pin = selectedPins; 
            currentSelectedGroup.poly = matchedPolygons; 

            const filteredData = [...currentSelectedGroup.pin, ...currentSelectedGroup.poly]; 
            
            const pinCount = currentSelectedGroup.pin.length;
            const polyCount = currentSelectedGroup.poly.length;
            const totalCount = pinCount + polyCount;
            
            selectedAddressText.textContent = 
                `é¸æŠã•ã‚ŒãŸåœ°åŸŸï¼š${selectedAddress} (åˆè¨ˆ ${totalCount} ä»¶: ãƒ”ãƒ³ ${pinCount} ä»¶ / ç…§åˆãƒãƒªã‚´ãƒ³ ${polyCount} ä»¶)\n${bboxStatusMessage}`;
            
            
            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®è¡¨ç¤º/æœ‰åŠ¹åŒ–/ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
            const downloadButtonContainer = document.getElementById('downloadButtonContainer');
            const downloadPinBtn = document.getElementById('downloadPinButton');
            const downloadPolyBtn = document.getElementById('downloadPolyButton');

            if (totalCount === 0) {
                downloadButtonContainer.style.display = 'none';
                table.innerHTML = '<thead><tr><th>ãƒ‡ãƒ¼ã‚¿ãªã—</th></tr></thead><tbody><tr><td>é¸æŠã•ã‚ŒãŸåœ°åŸŸã«è©²å½“ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</td></tr></tbody>';
                return;
            }
            
            downloadButtonContainer.style.display = 'block';
            
            // Pinãƒœã‚¿ãƒ³ã®æœ‰åŠ¹åŒ–ã¨ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
            downloadPinBtn.disabled = (pinCount === 0);
            downloadPinBtn.textContent = `ğŸ“ ãƒ”ãƒ³ ${pinCount} ä»¶ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰`;
            downloadPinBtn.style.display = pinCount > 0 ? 'inline-block' : 'none';

            // Polyãƒœã‚¿ãƒ³ã®æœ‰åŠ¹åŒ–ã¨ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
            downloadPolyBtn.disabled = (polyCount === 0);
            downloadPolyBtn.textContent = `ğŸ“ ç…§åˆãƒãƒªã‚´ãƒ³ ${polyCount} ä»¶ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰`;
            downloadPolyBtn.style.display = 'inline-block'; 
            
            
            // ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºç”¨ã®å‡¦ç†
            if (filteredData.length === 0) {
                table.innerHTML = '<thead><tr><th>ãƒ‡ãƒ¼ã‚¿ãªã—</th></tr></thead><tbody><tr><td>è¡¨ç¤ºã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</td></tr></tbody>';
                return;
            }

            const allProps = filteredData.flatMap(f => Object.keys(f.properties || {}));
            const uniqueHeaders = Array.from(new Set(allProps));

            // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã¦ã€GeoTypeã‚’å…ˆé ­ã«ã€ç·¯åº¦çµŒåº¦ã‚’æœ«å°¾ã«è¿½åŠ 
            let headers = ['GeoType', ...uniqueHeaders, 'Longitude', 'Latitude']; 

            const thead = table.createTHead();
            let headerRow = thead.insertRow();
            headers.forEach(header => {
                let th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            
            const tbody = table.createTBody();
            filteredData.forEach(feature => {
                let tr = tbody.insertRow(); 
                
                const props = feature.properties || {};
                const geomType = feature.geometry ? feature.geometry.type : 'None';
                const coords = (geomType === 'Point' && feature.geometry.coordinates) ? feature.geometry.coordinates : null;

                headers.forEach(header => {
                    let td = tr.insertCell(); 
                    if (header === 'GeoType') {
                        td.textContent = geomType;
                    } else if (header === 'Longitude' && coords) {
                        td.textContent = coords[0].toFixed(6); 
                    } else if (header === 'Latitude' && coords) {
                        td.textContent = coords[1].toFixed(6); 
                    } else if (['Longitude', 'Latitude'].includes(header)) {
                        td.textContent = '---'; 
                    } else {
                        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å€¤ãŒnullã‚„undefinedã®å ´åˆã¯ç©ºæ–‡å­—åˆ—ã‚’è¡¨ç¤º
                        td.textContent = props[header] !== undefined && props[header] !== null ? props[header] : ''; 
                    }
                });
            });
        }
        
        /**
         * é¸æŠã•ã‚ŒãŸåœ°åŸŸã®ãƒ”ãƒ³ï¼ˆPointï¼‰ãƒ•ã‚£ãƒ¼ãƒãƒ£ã‚’GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚
         */
        function downloadPinGeoJson() {
            if (currentSelectedGroup.pin.length === 0) return;

            const geoJsonOutput = {
                type: "FeatureCollection",
                features: currentSelectedGroup.pin
            };

            const selectedAddress = document.getElementById('selectedAddressText').textContent.split('\n')[0].split('(')[0].replace('é¸æŠã•ã‚ŒãŸåœ°åŸŸï¼š', '').trim();
            const filename = `PinData_Region_Extractor_${selectedAddress || 'data'}.geojson`;
            
            const dataStr = JSON.stringify(geoJsonOutput, null, 2); 
            const blob = new Blob([dataStr], { type: "application/geo+json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * é¸æŠã•ã‚ŒãŸåœ°åŸŸã®ãƒ”ãƒ³ã«å¯¾å¿œã™ã‚‹ãƒãƒªã‚´ãƒ³/ãƒ©ã‚¤ãƒ³ï¼ˆãã®ä»–ï¼‰ãƒ•ã‚£ãƒ¼ãƒãƒ£ã‚’GeoJSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚
         */
        function downloadPolyGeoJson() {
            if (currentSelectedGroup.poly.length === 0) return;

            const geoJsonOutput = {
                type: "FeatureCollection",
                features: currentSelectedGroup.poly
            };

            const selectedAddress = document.getElementById('selectedAddressText').textContent.split('\n')[0].split('(')[0].replace('é¸æŠã•ã‚ŒãŸåœ°åŸŸï¼š', '').trim();
            const filename = `PolygonData_Matched_BBox_${selectedAddress || 'data'}.geojson`; 
            
            const dataStr = JSON.stringify(geoJsonOutput, null, 2); 
            const blob = new Blob([dataStr], { type: "application/geo+json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>