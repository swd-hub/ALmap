<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>圃場ハイライト＋地図/衛星切替＋ファイル入出力サンプル</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { display: flex; margin: 0; }
    #map { width: 70%; height: 100vh; }
    #info { width: 30%; height: 100vh; overflow:auto; border-left: 1px solid #ccc; padding: 10px; }
    table { border-collapse: collapse; width: 100%; }
    td { border: 1px solid #ccc; padding: 4px; }
    .tiban-label {
      background: rgba(255,255,255,0.85);
      padding: 2px 8px;
      border: 1px solid #333;
      border-radius: 3px;
      font-size: 14px;
      pointer-events: none;
      font-weight: bold;
      white-space: nowrap;
    }
    #legend label {
      margin: 4px;
      display: inline-block;
      cursor: pointer;
    }
    #legend span {
      display:inline-block;
      width:18px;
      height:18px;
      border-radius:3px;
      margin-right:4px;
      vertical-align:middle;
      border:1px solid #333;
    }
    #outbtn {
      margin: 8px 0;
      width: 100%;
      height: 36px;
      font-size: 16px;
      background: #f8c363;
      border: 1px solid #d98400;
      border-radius: 5px;
      cursor: pointer;
    }
    .info-panel {
      position: fixed;
      top: 0;
      left: -300px; /* 初期は隠す */
      width: 300px;
      height: 100%;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      box-shadow: 2px 0 5px rgba(0,0,0,0.2);
      transition: left 0.3s ease;
      overflow-y: auto;
      z-index: 1000;
    }
    .info-panel.open {
      left: 0; /* スライドイン */
    }
.toggle-btn {
  position: fixed;         /* ← 画面に固定 */
  top: 10px;
  left: 10px;              /* ← 画面左上に表示 */
  width: 40px;
  height: 40px;
  background: #1565c0;
  color: #fff;
  text-align: center;
  line-height: 40px;
  cursor: pointer;
  border-radius: 5px;
  font-size: 20px;
  z-index: 2000;           /* ← 地図やUIより前面に出す */
}
.leaflet-control-zoom {
  top: 100px !important;   /* ← 位置を下にずらす */
  left: 10px !important;
}

    /* Leaflet のレイヤー切替コントロールが info パネルに隠れないように調整 */
    .leaflet-control-layers {
      margin-top: 10px;
      margin-right: 10px;
    }
  #infoResizer {
  position: absolute;
  top: 0;
  right: 0;
  width: 6px;
  height: 100%;
  cursor: ew-resize;
  background: rgba(0,0,0,0.05);
}

  </style>
</head>

<body>
  <div id="map"></div>
  <div id="info">
    <h3>選択した情報</h3>
    <div id="details">GeoJSONファイルを選択し、圃場をクリックしてください</div>
    <hr>
    <input type="file" id="fileInput" accept=".geojson,.json" multiple />
    <hr>
    <div id="legend"></div>
    <button id="outbtn">表示中の圃場をGeoJSONで保存</button>
  </div>
  
<div id="infoPanel" class="info-panel">
  <div id="infoToggle" class="toggle-btn">≡</div>
  <div id="infoContent"></div>
  <div id="infoResizer"></div> <!-- ← これを追加 -->
</div>



  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script>
// DOMが読み込まれてから実行
document.addEventListener("DOMContentLoaded", function() {
  // トグルボタン制御
  document.getElementById("infoToggle").addEventListener("click", function() {
    document.getElementById("infoPanel").classList.toggle("open");
  });

  const panel = document.getElementById("infoPanel");
  const resizer = document.getElementById("infoResizer");

  let isResizing = false;

  // リサイズバーをドラッグ開始
  resizer.addEventListener("mousedown", function(e) {
    isResizing = true;
    document.body.style.cursor = "ew-resize";
  });

  // ドラッグ中に幅を変更
  document.addEventListener("mousemove", function(e) {
    if (!isResizing) return;
    const newWidth = Math.min(Math.max(e.clientX, 200), 600); // 最小200px 最大600px
    panel.style.width = newWidth + "px";
  });

  // ドラッグ終了
  document.addEventListener("mouseup", function() {
    isResizing = false;
    document.body.style.cursor = "default";
  });
});

// ピンをクリックしたときに左パネルを開いて情報表示
function showProperties(props) {
  let html = "<table>";
  for (const key in props) {
    const jp = propertyLabels[key] ? propertyLabels[key] : "（訳なし）";
    html += `<tr>
      <td>${jp}</td>
      <td>${props[key]}</td>
    </tr>`;
  }
  html += "</table>";
  document.getElementById("infoContent").innerHTML = html;

  // ✅ ピンをクリックしたら自動で左パネルを開く
  document.getElementById("infoPanel").classList.add("open");
}



    // 作物カラーパレット定義
    const cropColors = {
      "主食用きぬむすめ": "#e57373",
      "主食用こしひかり": "#f06292",
      "稲WCS用きぬむすめ": "#ba68c8",
      "稲WCS用つきはやか": "#64b5f6",
      "飼料用米": "#4dd0e1",
      "大麦": "#4db6ac",
      "小麦": "#81c784",
      "ブロッコリー": "#dce775",
      "タマネギ": "#ffd54f",
      "デントコーン": "#ffb74d",
      "はとむぎ": "#a1887f",
      "さつまいも": "#f4511e",
      "大豆": "#789262",
      "その他": "#bdbdbd"
    };

    // UI：作物選択ラジオ
    function createCropLegend(crops) {
      const legendDiv = document.getElementById("legend");
      let html = "<h4>作物（ラジオ選択して圃場着色）</h4>";
      crops.forEach((crop, i) => {
        html += `<label>
          <input type="radio" name="crop" value="${crop}" ${i===0 ? "checked":""}>
          <span style="background:${cropColors[crop]};"></span>
          ${crop}
        </label><br>`;
      });
      legendDiv.innerHTML = html;
    }
    createCropLegend(Object.keys(cropColors));

    function getSelectedCrop() {
      const checked = document.querySelector('input[name="crop"]:checked');
      return checked ? checked.value : null;
    }

/*------------------------------------------------------
  プロパティ表示
------------------------------------------------------*/
 // 英→日ラベル辞書（FarmCommitteeCd追加）
    const propertyLabels = {
      // 主項目・参考画像・日本語訳対応
      Address:        "所在地",
      Tiban:          "地番",
      ClassificationOfLandCodeName: "地目",
      AreaOnRegistry: "面積（㎡）",
      SectionOfNoushinhouCodeName: "農振法区分",
      SectionOfToshikeikakuhouCodeName: "都市計画区分",
      OwnerFarmIntentionCodeName: "所有者の農地に関する意向",
      FarmerIndicationNumberHash: "耕作管理番号",
      KindOfRightCodeName:      "権利種別",
      KindOfRight:              "権利の種類",
      CommencementDate:         "存続期間の開始日",
      EndStagesDate:            "存続期間の終了日",
      RightSettingContentsCodeName: "農地中間管理権等権利設定の内容",
      UsageSituationInvestigationResultCodeName: "遊休農地関係（利用状況調査等）",
      UsageSituationInvestigationDate:   "利用状況調査日",
      UseIntentionInvestigationDate:     "利用意向調査日",
      OwnerStatementIntentSurveyResultsCodeName: "遊休農地関係（利用意向調査等）",
      UseIntentionAscertainmentResultCodeName:   "遊休農地関係（周辺地域への支障の除去等の指導）",
      ActionOrderDate:        "指導命令日",
      MayorPublicAnnouncementDate: "市町村長が措置を行う旨の公示を行った日",
      FarmCommitteeName:      "農業委員会名",
      FarmCommitteeCd:        "農業委員会コード",
      PublicNoticeDate:       "公告日",
      SectionOfPolygon:        "筆区分",
      SectionOfPolygonCodeName:"筆区分名",
      DaichoId:               "台帳ID",
      polygon_uuid:           "ポリゴンUUID",
      daicho_shubetsu_cd:     "台帳種別コード",
      SectionOfNoushinhou:    "農振法区分コード",
      SectionOfToshikeikakuhou:"都市計画法区分コード",
      AreaOnRegistryHa: "面積（ヘクタール）",
      ClassificationOfLand:   "地目コード",
      SectionOfPolygonName:   "筆区分名",
      UsageSituationInvestigationResult: "利用状況調査結果コード",
      OwnerStatementIntentSurveyResults: "所有者等の廃地の状況",
      UseIntentionAscertainmentResult: "利用意向把握結果コード",
      RecommendationContenDate: "勧告内容日",
      RightOfMiddleManagement: "農地中間管理権の状況",
      OazaCode: "大字コード",
      TodofukenCode: "都道府県コード",
      ShikuchosonCode: "市区町村コード"
    };


    // --- ベースレイヤー定義 ---
    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19, attribution: "© OpenStreetMap"
    });
    const esriSat = L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
        attribution: "Tiles © Esri"
      }
    );

    // マップ初期化（デフォルトは OSM）
    const map = L.map("map", {
      center: [35.404, 132.825], zoom: 16, layers: [osm]
    });

    // レイヤグループ
    const polygonLayerGroup = L.layerGroup().addTo(map);
    const markerLayerGroup  = L.layerGroup().addTo(map);
    const tibanLayerGroup   = L.layerGroup().addTo(map);

    // ベースレイヤーとオーバーレイをまとめてコントロールに追加
    const baseMaps = { "地図": osm, "衛星画像": esriSat };
    const overlayMaps = {
      "筆ポリゴン": polygonLayerGroup,
      "農地ピン": markerLayerGroup,
      "地番ラベル": tibanLayerGroup
    };
    L.control.layers(baseMaps, overlayMaps).addTo(map);

    // 選択されたポリゴン一覧
    let selectedFeatures = [];
    const originalPolygonStyles = new WeakMap();

// ファイル読み込み処理
document.getElementById("fileInput").addEventListener("change", function(event) {
  const files = event.target.files;
  for (const file of files) {
    const reader = new FileReader();
    reader.onload = function(e) {
      let geojson;
      try {
        geojson = JSON.parse(e.target.result);
      } catch {
        alert("ファイルの読み込みに失敗: " + file.name);
        return;
      }
      L.geoJSON(geojson, {
        style: function(feature) {
          if (feature.geometry.type === "Polygon" || feature.geometry.type === "MultiPolygon") {
            const crop = feature.properties?.SelectedCrop;
            return {
              color: "#d00",
              weight: 2,
              fillColor: cropColors[crop] || "#e88",
              fillOpacity: crop && cropColors[crop] ? 0.7 : 0.3
            };
          }
        },
        onEachFeature: function(feature, lyr) {
          if (feature.geometry.type === "Polygon" || feature.geometry.type === "MultiPolygon") {
            polygonLayerGroup.addLayer(lyr);
            originalPolygonStyles.set(lyr, {
              color: lyr.options.color,
              weight: lyr.options.weight,
              fillColor: lyr.options.fillColor,
              fillOpacity: lyr.options.fillOpacity
            });

            // 地番ラベル
            let coords;
            if (feature.geometry.type === "Polygon" && feature.geometry.coordinates.length > 0) {
              coords = feature.geometry.coordinates[0][0];
            } else if (feature.geometry.type === "MultiPolygon" && feature.geometry.coordinates.length > 0) {
              coords = feature.geometry.coordinates[0][0][0];
            }
            if (coords) {
              const tibanLabel = L.marker([coords[1], coords[0]], {
                icon: L.divIcon({
                  className: "tiban-label",
                  html: String(feature.properties?.Tiban || ""),
                  iconSize: null
                }),
                interactive: false
              });
              tibanLayerGroup.addLayer(tibanLabel);
            }

            // 圃場クリック時にトグル動作（面積はカウントせず着色のみ）
            lyr.on("click", function(e) {
              const crop = getSelectedCrop();
              const idx = selectedFeatures.findIndex(sel => sel.lyr === lyr);
              if (idx >= 0) {
                restorePolygonStyle(lyr);
                selectedFeatures.splice(idx, 1);
              } else {
                if (crop && cropColors[crop]) {
                  lyr.setStyle({
                    fillColor: cropColors[crop],
                    fillOpacity: 0.7,
                    color: "#111",
                    weight: 3
                  });
                  feature.properties.SelectedCrop = crop;
                }
                selectPolygonStyle(lyr);
                selectedFeatures.push({ lyr, feature });
              }
              showSelectedFeatureProperties();
            });

          } else if (feature.geometry.type === "Point") {
            const latlng = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]];
            const marker = L.marker(latlng, {
              icon: L.icon({
                iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",
                shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
              })
            });

            marker.feature = feature; // ✅ featureを保持
            markerLayerGroup.addLayer(marker);

            // ✅ ピンをクリックしたときの処理
            marker.on("click", function() {
              const idx = selectedFeatures.findIndex(sel => sel.lyr === marker);
              if (idx >= 0) {
                selectedFeatures.splice(idx, 1);
              } else {
                selectedFeatures.push({ lyr: marker, feature });
              }

              // 左情報欄に表示
              const props = feature.properties;
              let html = "<table>";
              for (const key in props) {
                const jp = propertyLabels[key] ? propertyLabels[key] : "（訳なし）";
                html += `<tr>
                  <td>${jp}</td>
                  <td>${props[key]}</td>
                </tr>`;
              }
              html += "</table>";
              document.getElementById("infoContent").innerHTML = html;

              // 左パネルを自動で開く
              document.getElementById("infoPanel").classList.add("open");

              // 複数選択時の合計面積は従来通り右側 details に表示
              showSelectedFeatureProperties();
            });

            if (feature.properties && feature.properties.Tiban) {
              const tibanLabel = L.marker(latlng, {
                icon: L.divIcon({
                  className: "tiban-label",
                  html: String(feature.properties.Tiban),
                  iconSize: null
                }),
                interactive: false
              });
              tibanLayerGroup.addLayer(tibanLabel);
            }
          }
        }
      });
    };
    reader.readAsText(file);
  }
});
// プロパティ表示関数
function showProperties(props) {
  let html = "<table>";
  for (const key in props) {
    const jp = propertyLabels[key] ? propertyLabels[key] : "（訳なし）";
    html += `<tr>
      <td>${jp}</td>
      <td>${props[key]}</td>
    </tr>`;
  }
  html += "</table>";
  document.getElementById("infoContent").innerHTML = html; // ✅ 左パネルに表示
}




// 複数選択フィーチャ用: 地番・面積と合計（属性 AreaOnRegistry を使用）
function showSelectedFeatureProperties() {
  if (selectedFeatures.length === 0) {
    document.getElementById("details").innerHTML =
      "GeoJSONファイルを選択し、圃場をクリックしてください";
    return;
  } else if (selectedFeatures.length === 1) {
    console.log("1件選択:", selectedFeatures[0]);
    // ✅ 単一選択時は左パネルに詳細を表示するので右パネルは不要
    return;
  }

  console.log("選択されたフィーチャ一覧:", selectedFeatures);

  let html = `<div style="color:#1565c0;font-weight:bold;margin-bottom:6px;">選択ピン数: ${selectedFeatures.length}</div>`;
  let totalArea = 0;
  html += "<table>";

  selectedFeatures.forEach((item, index) => {
    const feature = item.feature;
    const props = feature?.properties || {};
    let area = 0;

    if (feature.geometry.type === "Point" && props.Tiban) {
      area = parseFloat(props.AreaOnRegistry) || 0;
      totalArea += area;

      html += `<tr>
        <td>${props.Tiban}</td>
        <td style="text-align:right;">${area.toLocaleString()} ㎡</td>
      </tr>`;
    }
  });

  html += "</table>";
  html += `<div style="color:#1565c0;font-weight:bold;margin-top:10px;">合計面積: ${totalArea.toLocaleString()} ㎡ (${(totalArea / 10000).toFixed(4)} ha)</div>`;
  document.getElementById("details").innerHTML = html; // ✅ 右パネルに表示
}



    // 強調枠（選択状態を分かりやすくしたい場合用）
    function selectPolygonStyle(lyr) {
      lyr.setStyle && lyr.setStyle({
        color: "#0057ff",
        weight: 4
      });
    }
    
    function restorePolygonStyle(lyr) {
      const orig = originalPolygonStyles.get(lyr) || {};
      lyr.setStyle && lyr.setStyle({
        color: orig.color || "#d00",
        weight: orig.weight || 2,
        fillColor: orig.fillColor || "#e88",
        fillOpacity: orig.fillOpacity || 0.3
      });
    }

    // 圃場GeoJSONを書き出す
    document.getElementById('outbtn').addEventListener('click', function() {
      const geojson = polygonLayerGroup.toGeoJSON();
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(geojson, null, 2));
      const dlAnchor = document.createElement('a');
      dlAnchor.setAttribute("href", dataStr);
      dlAnchor.setAttribute("download", "fields_export.geojson");
      document.body.appendChild(dlAnchor);
      dlAnchor.click();
      document.body.removeChild(dlAnchor);
    });
    
  </script>
</body>
</html>
