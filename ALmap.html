<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>圃場ハイライト＋地図/衛星切替＋ファイル入出力サンプル（修正版）</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { display: flex; margin: 0; }
    #map { width: 85%; height: 100vh; }
    #info { width: 15%; height: 100vh; overflow:auto; border-left: 1px solid #ccc; padding: 10px; }
    table { border-collapse: collapse; width: 100%; table-layout: fixed; }
    td, th { border: 1px solid #ccc; padding: 4px; word-wrap: break-word; }
    th:first-child, td:first-child { width: 50%; }
    th:last-child, td:last-child { width: 50%; }

    .tiban-label {
      background: rgba(255,255,255,0.85);
      padding: 2px 8px;
      border: 1px solid #333;
      border-radius: 3px;
      font-size: 14px;
      pointer-events: none;
      font-weight: bold;
      white-space: nowrap;
    }
    #legend label {
      margin: 4px;
      display: inline-block;
      cursor: pointer;
    }
    #legend span {
      display:inline-block;
      width:18px;
      height:18px;
      border-radius:3px;
      margin-right:4px;
      vertical-align:middle;
      border:1px solid #333;
    }
    .legend-hatch {
      background-image: repeating-linear-gradient(
        45deg,
        rgba(0,0,0,0.3) 0px,
        rgba(0,0,0,0.3) 2px,
        transparent 2px,
        transparent 14px
      );
      background-size: 14px 14px;
    }
    #outbtn {
      margin: 8px 0;
      width: 100%;
      height: 36px;
      font-size: 16px;
      background: #f8c363;
      border: 1px solid #d98400;
      border-radius: 5px;
      cursor: pointer;
    }
    .info-panel {
      position: fixed;
      top: 0;
      left: -300px;
      width: 300px;
      height: 100%;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      box-shadow: 2px 0 5px rgba(0,0,0,0.2);
      transition: left 0.3s ease;
      overflow-y: auto;
      z-index: 1000;
    }
    .info-panel.open { left: 0; }
    .toggle-btn {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      background: #1565c0;
      color: #fff;
      text-align: center;
      line-height: 40px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 20px;
      z-index: 2000;
    }
    .leaflet-control-zoom {
      top: 100px !important;
      left: 10px !important;
    }
    .leaflet-control-layers {
      margin-top: 10px;
      margin-right: 10px;
    }
    #infoResizer {
      position: absolute;
      top: 0;
      right: 0;
      width: 6px;
      height: 100%;
      cursor: ew-resize;
      background: rgba(0,0,0,0.05);
    }
    .info-title {
      display: block;
      margin: 0 0 8px 0;
      font-size: 18px;
      font-weight: bold;
      color: #1565c0;
      border-bottom: 2px solid #ccc;
      padding-bottom: 4px;
    }
    #infoContent {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 60px 12px 12px 12px;
      overflow-y: auto;
      height: 100%;
      box-sizing: border-box;
    }
    .info-panel { z-index: 1000; }
    #loadedFileNamesDisplay {
      margin-top: 5px;
      font-size: 0.9em;
      color: #555;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #eee;
      padding: 5px;
      background-color: #f9f9f9;
      border-radius: 3px;
    }
    #loadedFileNamesDisplay ul { margin: 0; padding-left: 20px; }
    #loadedFileNamesDisplay li { margin-bottom: 2px; word-break: break-all; }
    #clearSelectedFeaturesBtn {
      margin-top: 5px;
      padding: 5px 10px;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 0.9em;
      width: 100%;
    }
    #clearSelectedFeaturesBtn:hover { background-color: #d32f2f; }
    #map .leaflet-interactive { cursor: pointer !important; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="info">
    <h3>情報</h3>
    <div id="details">GeoJSONファイルを選択し、農地ピンと筆ポリゴン（境界）を読み込んでください</div>
    <button id="clearSelectedFeaturesBtn">面積集計をクリア</button>
    <hr>
    <input type="file" id="fileInput" accept=".geojson,.json" multiple />
    <div id="loadedFileNamesDisplay"></div>
    <hr>
    <div id="legend"></div>
    <button id="outbtn">作物をGeoJSONファイルで保存</button>

    <div id="infoPanel" class="info-panel">
      <div id="infoToggle" class="toggle-btn">≡</div>
      <div id="infoContent">
        <h3 class="info-title">詳細情報</h3>
        <div id="propertyDetails"></div>
      </div>
      <div id="infoResizer"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script>
let selectedFeatures = [];
let loadedFileNames = [];
let map; 

const propertyLabels = {
  FarmCommitteeCd: "農業委員会コード",
  FarmCommitteeName: "農業委員会名",
  TodofukenCode: "都道府県コード",
  ShikuchosonCode: "市町村コード",
  OazaCode: "大字コード",
  ClassificationOfLandCodeName: "地目",
  ClassificationOfLand: "地目コード",
  AreaOnRegistry: "登記簿面積（㎡）",
  SectionOfNoushinhouCodeName: "農振法区分",
  SectionOfNoushinhou: "農振法区分コード",
  SectionOfToshikeikakuhouCodeName: "都市計画法区分",
  SectionOfToshikeikakuhou: "都市計画法区分コード",
  OwnerFarmIntentionCodeName: "所有者の農地に関する意向",
  OwnerFarmIntention: "所有者の農地に関する意向コード",
  FarmerIndicationNumberHash: "耕作者整理番号",
  KindOfRightCodeName: "権利の種類",
  KindOfRight: "権利の種類コード",
  CommencementDate: "存続期間（始期）",
  EndStagesDate: "存続期間（終期）",
  RightSettingContentsCodeName: "農地中間管理権の状況",
  RightSettingContents: "農地中間管理権コード",
  UsageSituationInvestigationDate: "利用状況調査日",
  UsageSituationInvestigationResultCodeName: "遊休農地かどうか",
  UsageSituationInvestigationResult: "遊休農地コード",
  UseIntentionInvestigationDate: "利用意向調査日",
  OwnerStatementIntentSurveyResultsCodeName: "遊休農地の所有者等の意向",
  OwnerStatementIntentSurveyResults: "遊休農地コード",
  UseIntentionAscertainmentResultCodeName: "所有者等の確知の状況",
  UseIntentionAscertainmentResult: "所有者等の確知コード",
  PublicNoticeDate: "公告日",
  RightOfMiddleManagement: "農地中間管理権裁定日",
  RecommendationContenDate: "勧告日",
  ActionOrderDate: "措置命令日",
  MayorPublicAnnouncementDate: "市町村長公示日",
  Address: "所在地・地番",
  Tiban: "地番",
  SectionOfPolygonCodeName: "ポリゴン区分",
  SectionOfPolygon: "ポリゴン区分コード",
  DaichoId: "台帳ID",
  daicho_shubetsu_cd: "台帳種別コード"
};

// --- 色定義 ---
const cropColors = {
  "主食用きぬむすめ": "#90ee90",
  "主食用つや姫": "#ffc0cb",
  "主食用つきあかり": "#add8e6",
  "主食用コシヒカリ": "#6a5acd",
  "稲WCS用きぬむすめ": "#90ee90",
  "稲WCS用つきはやか": "#9acd32",
  "稲WCS用たちすずか": "#d2b48c",
  "稲WCS用ヒメノモチ": "#ffb6c1",
  "飼料用米": "#dda0dd",
  "大麦": "#ffcc99",
  "小麦": "#ff8c00",
  "ブロッコリー": "#228b22",
  "タマネギ": "#deb887",
  "飼料用トウモロコシ": "#ffff00",
  "はとむぎ": "#654321",
  "さつまいも": "#800080",
  "大豆": "#f4a300",
  "その他": "#bdbdbd"
};

// 凡例の表示順
const cropOrder = [
  "主食用きぬむすめ","主食用つや姫","主食用つきあかり","主食用コシヒカリ",
  "稲WCS用きぬむすめ","稲WCS用つきはやか","稲WCS用たちすずか","稲WCS用ヒメノモチ",
  "飼料用米","大麦","小麦","ブロッコリー","タマネギ","飼料用トウモロコシ","はとむぎ","さつまいも","大豆","その他"
];

function isHatchedCrop(cropName) {
  const n = normalizeCrop(cropName);
  return n && (n.includes("飼料用") || n.includes("WCS用"));
}

function normalizeCrop(name) {
  if (!name && name !== "") return name;
  return String(name).replace(/\u3000/g, " ").replace(/\s+/g, "").trim();
}

// ★修正箇所★ 警告を出さないように変更
function getBaseCropNameForHatching(cropName) {
  const crop = normalizeCrop(cropName);

  if (crop && crop.startsWith("稲WCS用")) {
    const variety = crop.replace("稲WCS用", "");
    const candidate = `主食用${variety}`;
    
    // 主食用が存在すれば、その色をベース（ハッチング背景）にする
    if (cropColors[candidate]) {
        return candidate;
    }
    // 主食用が存在しない場合（たちすずか等）は、警告を出さずに
    // そのままの名前を返す（cropColorsにWCS用の定義があるため）
  }
  return crop;
}

function injectSvgHatchPattern(mapInstance, patternId, backgroundColor) {
  if (!mapInstance) return;

  const renderer = mapInstance.getRenderer(mapInstance);
  if (!renderer || !renderer._container) return;
  const svg = renderer._container;

  let defs = svg.querySelector("defs");
  if (!defs) {
    defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    svg.insertBefore(defs, svg.firstChild);
  }
  if (defs.querySelector(`#${patternId}`)) return;

  const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
  pattern.setAttribute("id", patternId);
  pattern.setAttribute("x", "0");
  pattern.setAttribute("y", "0");
  pattern.setAttribute("width", "10");
  pattern.setAttribute("height", "10");
  pattern.setAttribute("patternUnits", "userSpaceOnUse");

  const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  rect.setAttribute("x", "0");
  rect.setAttribute("y", "0");
  rect.setAttribute("width", "10");
  rect.setAttribute("height", "10");
  rect.setAttribute("fill", backgroundColor);
  pattern.appendChild(rect);

  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("x1", "0");
  line.setAttribute("y1", "0");
  line.setAttribute("x2", "10");
  line.setAttribute("y2", "10");
  line.setAttribute("stroke", "#000");
  line.setAttribute("stroke-width", "1");
  line.setAttribute("stroke-opacity", "0.5");
  pattern.appendChild(line);

  defs.appendChild(pattern);
}

function getPolygonRenderStyle(cropName, isSelected = false) {
  let currentFill;
  let currentFillOpacity = "0.7";
  let currentStroke = "#d00";
  let currentStrokeWidth = "2";

  if (isSelected) {
    currentStroke = "#0057ff";
    currentStrokeWidth = "4";
  }

  const n = normalizeCrop(cropName);
  if (n === null || n === undefined || n === "") {
    currentFill = "transparent";
    currentFillOpacity = "0.0";
  } else if (isHatchedCrop(n)) {
    const baseCropName = getBaseCropNameForHatching(n);
    const hatchBackgroundColor = cropColors[baseCropName] || cropColors["その他"] || "#e88";
    
    if (map) {
      const uniqueHatchPatternId =
        `hatch-${baseCropName.replace(/[^a-zA-Z0-9\u3040-\u30FF\u4E00-\u9FAF]/g, '-')}-${map._leaflet_id}`;
      injectSvgHatchPattern(map, uniqueHatchPatternId, hatchBackgroundColor);
      currentFill = `url(#${uniqueHatchPatternId})`;
    } else {
      currentFill = hatchBackgroundColor;
    }
  } else {
    currentFill = cropColors[n] || cropColors["その他"] || "#e88";
  }

  return {
    fill: currentFill,
    fillOpacity: currentFillOpacity,
    stroke: currentStroke,
    strokeWidth: currentStrokeWidth
  };
}

function createCropLegend(crops) {
  const legendDiv = document.getElementById("legend");
  let html = "<h4>作物（ラジオ選択して圃場をクリック）</h4>";
  crops.forEach((crop, i) => {
    const baseCropName = getBaseCropNameForHatching(crop);
    const hatchClass = isHatchedCrop(crop) ? "legend-hatch" : "";
    const legendColor = cropColors[baseCropName] || cropColors["その他"] || "#e88";
    html += `<label>
      <input type="radio" name="crop" value="${crop}" ${i===0 ? "checked":""}>
      <span class="${hatchClass}" style="background-color:${legendColor};"></span>
      ${crop}
    </label><br>`;
  });
  legendDiv.innerHTML = html;
}

function getSelectedCrop() {
  const checked = document.querySelector('input[name="crop"]:checked');
  if (!checked) return null;
  const v = checked.value.replace(/\u3000/g, " ").replace(/\s+/g, "").trim();
  return v;
}

document.addEventListener("DOMContentLoaded", function() {

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19, attribution: "© OpenStreetMap" });
  const esriSat = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", { attribution: "Tiles © Esri" });

  map = L.map("map", { 
    center: [35.404, 132.825],
    zoom: 17,
    layers: [osm],
    renderer: L.svg()
  });

  setTimeout(function() {
    map.invalidateSize();
  }, 100);

  window.polygonLayerGroup = L.layerGroup().addTo(map);
  const markerLayerGroup  = L.layerGroup().addTo(map);
  const tibanLayerGroup   = L.layerGroup().addTo(map);

  const baseMaps = { "地図": osm, "衛星画像": esriSat };
  const overlayMaps = { "筆ポリゴン": polygonLayerGroup, "農地ピン": markerLayerGroup, "地番ラベル": tibanLayerGroup };
  L.control.layers(baseMaps, overlayMaps).addTo(map);

  map.doubleClickZoom.disable();
  document.getElementById("infoToggle").addEventListener("click", function() {
    document.getElementById("infoPanel").classList.toggle("open");
  });

  const panel = document.getElementById("infoPanel");
  const resizer = document.getElementById("infoResizer");
  let isResizing = false;
  resizer.addEventListener("mousedown", function() {
    isResizing = true; document.body.style.cursor = "ew-resize";
  });
  document.addEventListener("mousemove", function(e) {
    if (!isResizing) return;
    const newWidth = Math.min(Math.max(e.clientX, 200), 600);
    panel.style.width = newWidth + "px";
  });
  document.addEventListener("mouseup", function() {
    isResizing = false; document.body.style.cursor = "default";
  });

  updateLoadedFileNamesDisplay();

  document.getElementById("clearSelectedFeaturesBtn").addEventListener("click", function() {
    selectedFeatures = [];
    showSelectedFeatureProperties();
    document.getElementById("propertyDetails").innerHTML = "";
  });

  map.on('overlayadd', function(e) {
    if (e.layer === polygonLayerGroup) {
      polygonLayerGroup.eachLayer(function(lyr) {
        restorePolygonStyle(lyr);
      });
    }
  });

  createCropLegend(cropOrder);

  document.getElementById("fileInput").addEventListener("change", function(event) {
    const files = event.target.files;
    if (files.length === 0) { updateLoadedFileNamesDisplay(); return; }

    let filesToProcessCount = 0;
    const totalFilesSelected = files.length;

    Array.from(files).forEach(file => {
      const reader = new FileReader();

      if (loadedFileNames.includes(file.name)) {
        alert(`同じ名前のファイル「${file.name}」は既に読み込まれています。`);
        filesToProcessCount++;
        if (filesToProcessCount === totalFilesSelected) updateLoadedFileNamesDisplay();
        return;
      }

      reader.onload = function(e) {
        let geojson;
        try {
          geojson = JSON.parse(e.target.result);
        } catch (error) {
          alert(`ファイルの読み込みに失敗: ${file.name} - ${error.message}`);
          filesToProcessCount++;
          if (filesToProcessCount === totalFilesSelected) updateLoadedFileNamesDisplay();
          return;
        }

        L.geoJSON(geojson, {
          onEachFeature: function(feature, lyr) {
            if (feature.geometry.type === "Polygon" || feature.geometry.type === "MultiPolygon") {
              polygonLayerGroup.addLayer(lyr);

              const initialCrop = normalizeCrop(feature.properties?.SelectedCrop);
              const initialStyle = getPolygonRenderStyle(initialCrop, false);

              if (lyr._path) {
                lyr._path.setAttribute('fill', initialStyle.fill);
                lyr._path.setAttribute('fill-opacity', initialStyle.fillOpacity);
                lyr._path.setAttribute('stroke', initialStyle.stroke);
                lyr._path.setAttribute('stroke-width', initialStyle.strokeWidth);
              } else {
                const baseCropName = getBaseCropNameForHatching(initialCrop);
                const fillColorForCanvas = (initialStyle.fill === "transparent")
                  ? "transparent"
                  : (cropColors[baseCropName] || cropColors["その他"] || "#e88");
                lyr.setStyle({
                  color: initialStyle.stroke,
                  weight: Number(initialStyle.strokeWidth),
                  fillColor: fillColorForCanvas,
                  fillOpacity: parseFloat(initialStyle.fillOpacity)
                });
              }

              // 筆ポリゴンの地番ラベル
              let coords;
              if (feature.geometry.type === "Polygon" && feature.geometry.coordinates.length > 0) {
                coords = feature.geometry.coordinates[0][0];
              } else if (feature.geometry.type === "MultiPolygon" && feature.geometry.coordinates.length > 0) {
                coords = feature.geometry.coordinates[0][0][0];
              }
              if (coords) {
                const tibanLabelText = String(feature.properties?.Tiban || "");
                if (tibanLabelText.trim() !== "") {
                  const tibanLabel = L.marker([coords[1], coords[0]], {
                    icon: L.divIcon({
                      className: "tiban-label",
                      html: tibanLabelText,
                      iconSize: null
                    }),
                    interactive: false
                  });
                  tibanLayerGroup.addLayer(tibanLabel);
                }
              }

              lyr.on("click", function(e) {
                L.DomEvent.stopPropagation(e);
                const crop = getSelectedCrop();

                const idx = selectedFeatures.findIndex(sel => sel.lyr === lyr);

                if (idx >= 0) {
                  feature.properties.SelectedCrop = null;
                  restorePolygonStyle(lyr);
                  selectedFeatures.splice(idx, 1);
                } else {
                  if (crop) {
                    feature.properties.SelectedCrop = crop;
                    const selectedStyle = getPolygonRenderStyle(crop, true);

                    if (lyr._path) {
                      lyr._path.setAttribute('fill', selectedStyle.fill);
                      lyr._path.setAttribute('fill-opacity', selectedStyle.fillOpacity);
                      lyr._path.setAttribute('stroke', selectedStyle.stroke);
                      lyr._path.setAttribute('stroke-width', selectedStyle.strokeWidth);
                    } else {
                      const baseCropName = getBaseCropNameForHatching(crop);
                      const fillColorForCanvas = (selectedStyle.fill === "transparent")
                        ? "transparent"
                        : (cropColors[baseCropName] || cropColors["その他"] || "#e88");
                      lyr.setStyle({
                        color: selectedStyle.stroke,
                        weight: Number(selectedStyle.strokeWidth),
                        fillColor: fillColorForCanvas,
                        fillOpacity: parseFloat(selectedStyle.fillOpacity)
                      });
                    }
                  }
                  selectedFeatures.push({ lyr, feature });
                }
              });

            } else if (feature.geometry.type === "Point") {
              const latlng = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]];
              const marker = L.marker(latlng, {
                icon: L.icon({
                  iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",
                  shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
                  iconSize: [25, 41],
                  iconAnchor: [12, 41],
                  popupAnchor: [1, -34],
                  shadowSize: [41, 41]
                })
              });

              marker.feature = feature;
              markerLayerGroup.addLayer(marker);

              marker.on("click", function(e) {
                L.DomEvent.stopPropagation(e);
                const idx = selectedFeatures.findIndex(sel => sel.lyr === marker);
                if (idx >= 0) {
                  selectedFeatures.splice(idx, 1);
                } else {
                  selectedFeatures.push({ lyr: marker, feature });
                }
                const props = feature.properties;
                let html = "<table>";
                for (const key in props) {
                  const jp = propertyLabels[key] ? propertyLabels[key] : "（訳なし）";
                  html += `<tr><td>${jp}</td><td>${props[key]}</td></tr>`;
                }
                html += "</table>";
                document.getElementById("propertyDetails").innerHTML = html;
                document.getElementById("infoPanel").classList.add("open");
                showSelectedFeatureProperties();
              });

              const tibanLabelText = String(feature.properties?.Tiban || "");
              if (tibanLabelText.trim() !== "") {
                const tibanLabel = L.marker(latlng, {
                  icon: L.divIcon({
                    className: "tiban-label",
                    html: tibanLabelText,
                    iconSize: null
                  }),
                  interactive: false
                });
                tibanLayerGroup.addLayer(tibanLabel);
              }
            }
          }
        });

        if (!loadedFileNames.includes(file.name)) loadedFileNames.push(file.name);
        filesToProcessCount++;
        if (filesToProcessCount === totalFilesSelected) updateLoadedFileNamesDisplay();
      };

      reader.onerror = function() {
        alert(`ファイルの読み込み中にエラーが発生しました: ${file.name}`);
        filesToProcessCount++;
        if (filesToProcessCount === totalFilesSelected) updateLoadedFileNamesDisplay();
      };
      reader.readAsText(file);
    });
  });

  document.getElementById('outbtn').addEventListener('click', async function() {
    const geojson = polygonLayerGroup.toGeoJSON();
    const dataToSave = JSON.stringify(geojson, null, 2);

    const now = new Date();
    const timestamp =
      now.getFullYear().toString() +
      String(now.getMonth() + 1).padStart(2, "0") +
      String(now.getDate()).padStart(2, "0") +
      String(now.getHours()).padStart(2, "0") +
      String(now.getMinutes()).padStart(2, "0");
    const defaultFilename = `ALmapData${timestamp}.geojson`;

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: defaultFilename,
          types: [{ description: 'GeoJSON Files', accept: { 'application/json': ['.geojson', '.json'] } }],
        });
        const writableStream = await handle.createWritable();
        await writableStream.write(new Blob([dataToSave], { type: 'application/json' }));
        await writableStream.close();
        alert('ファイルが保存されました。');
      } catch (err) {
        if (err.name === 'AbortError') {
          console.log('ファイルの保存がキャンセルされました。');
        } else {
          console.error('ファイルの保存中にエラーが発生しました:', err);
          alert('ファイルの保存中にエラーが発生しました。詳細はコンソールを確認してください。');
        }
      }
    } else {
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(dataToSave);
      const dlAnchor = document.createElement('a');
      dlAnchor.setAttribute("href", dataStr);
      dlAnchor.setAttribute("download", defaultFilename);
      document.body.appendChild(dlAnchor);
      dlAnchor.click();
      document.body.removeChild(dlAnchor);
      alert('ファイルがダウンロードされました（ブラウザのダウンロード設定に従います）。');
    }
  });
});

function updateLoadedFileNamesDisplay() {
  const displayElement = document.getElementById("loadedFileNamesDisplay");
  if (!displayElement) return;
  if (loadedFileNames.length === 0) {
    displayElement.innerHTML = "<em>読み込まれたファイルはありません。</em>";
    return;
  }
  let fileListHtml = `<div style="font-weight: bold;">読み込み済みファイル (${loadedFileNames.length}個):</div><ul>`;
  loadedFileNames.forEach(name => { fileListHtml += `<li>${name}</li>`; });
  fileListHtml += `</ul>`;
  displayElement.innerHTML = fileListHtml;
}

function showSelectedFeatureProperties() {
  const selectedPins = selectedFeatures.filter(item => item.feature.geometry.type === "Point");
  if (selectedPins.length === 0) {
    document.getElementById("details").innerHTML =
      "GeoJSONファイルを選択し、農地ピンと筆ポリゴン（境界）を読み込んでください";
    return;
  }
  let html = `<div style="color:#1565c0;font-weight:bold;margin-bottom:6px;">選択ピン数: ${selectedPins.length}</div>`;
  let totalArea = 0;
  html += "<table>";
  html += "<thead><tr><th>地番</th><th>面積</th></tr></thead><tbody>";
  selectedPins.forEach((item) => {
    const props = item.feature?.properties || {};
    let area = parseFloat(props.AreaOnRegistry) || 0;
    totalArea += area;
    html += `<tr><td>${props.Tiban || 'N/A'}</td><td style="text-align:right;">${area.toLocaleString()} ㎡</td></tr>`;
  });
  html += "</tbody></table>";
  html += `<div style="color:#1565c0;font-weight:bold;margin-top:10px;">合計面積: ${totalArea.toLocaleString()} ㎡ (${(totalArea / 10000).toFixed(4)} ha)</div>`;
  document.getElementById("details").innerHTML = html;
}

function restorePolygonStyle(lyr) {
  const currentCrop = normalizeCrop(lyr.feature.properties?.SelectedCrop);
  const styleToRestore = getPolygonRenderStyle(currentCrop, false);

  if (lyr._path) {
    lyr._path.setAttribute('fill', styleToRestore.fill);
    lyr._path.setAttribute('fill-opacity', styleToRestore.fillOpacity);
    lyr._path.setAttribute('stroke', styleToRestore.stroke);
    lyr._path.setAttribute('stroke-width', styleToRestore.strokeWidth);
  } else if (lyr.setStyle) {
    const baseCropName = getBaseCropNameForHatching(currentCrop);
    const fillColorForCanvas = (styleToRestore.fill === "transparent")
      ? "transparent"
      : (cropColors[baseCropName] || cropColors["その他"] || "#e88");
    lyr.setStyle({
      color: styleToRestore.stroke,
      weight: Number(styleToRestore.strokeWidth),
      fillColor: fillColorForCanvas,
      fillOpacity: parseFloat(styleToRestore.fillOpacity)
    });
  }
}
  </script>
</body>

</html>
