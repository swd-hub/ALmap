<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>GeoJSON取り込み＋情報パネル＋地図切替＋地番ラベル</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { display: flex; margin: 0; }
    #map { width: 70%; height: 100vh; }
    #info { width: 30%; height: 100vh; overflow:auto; border-left: 1px solid #ccc; padding: 10px; }
    table { border-collapse: collapse; width: 100%; }
    td { border: 1px solid #ccc; padding: 4px; }
    .tiban-label {
      background: rgba(255,255,255,0.85);
      padding: 2px 8px;
      border: 1px solid #333;
      border-radius: 3px;
      font-size: 14px;
      pointer-events: none;
      font-weight: bold;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="info">
    <h3>選択した情報</h3>
    <div id="details">GeoJSONファイルを選択し、ピンやポリゴンをクリックしてください</div>
    <hr>
    <input type="file" id="fileInput" accept=".geojson,.json" multiple />
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // 英→日ラベル辞書（FarmCommitteeCd追加）
    const propertyLabels = {
      // 主項目・参考画像・日本語訳対応
      Address:        "所在地",
      Tiban:          "地番",
      ClassificationOfLandCodeName: "地目",
      AreaOnRegistry: "面積（㎡）",
      SectionOfNoushinhouCodeName: "農振法区分",
      SectionOfToshikeikakuhouCodeName: "都市計画区分",
      OwnerFarmIntentionCodeName: "所有者の農地に関する意向",
      FarmerIndicationNumberHash: "耕作管理番号",
      KindOfRightCodeName:      "権利種別",
      KindOfRight:              "権利の種類",
      CommencementDate:         "存続期間の開始日",
      EndStagesDate:            "存続期間の終了日",
      RightSettingContentsCodeName: "農地中間管理権等権利設定の内容",
      UsageSituationInvestigationResultCodeName: "遊休農地関係（利用状況調査等）",
      UsageSituationInvestigationDate:   "利用状況調査日",
      UseIntentionInvestigationDate:     "利用意向調査日",
      OwnerStatementIntentSurveyResultsCodeName: "遊休農地関係（利用意向調査等）",
      UseIntentionAscertainmentResultCodeName:   "遊休農地関係（周辺地域への支障の除去等の指導）",
      ActionOrderDate:        "指導命令日",
      MayorPublicAnnouncementDate: "市町村長が措置を行う旨の公示を行った日",
      FarmCommitteeName:      "農業委員会名",
      FarmCommitteeCd:        "農業委員会コード",
      PublicNoticeDate:       "公告日",
      SectionOfPolygon:        "筆区分",
      SectionOfPolygonCodeName:"筆区分名",
      DaichoId:               "台帳ID",
      polygon_uuid:           "ポリゴンUUID",
      daicho_shubetsu_cd:     "台帳種別コード",
      SectionOfNoushinhou:    "農振法区分コード",
      SectionOfToshikeikakuhou:"都市計画法区分コード",
      AreaOnRegistryHa: "面積（ヘクタール）",
      ClassificationOfLand:   "地目コード",
      SectionOfPolygonName:   "筆区分名",
      UsageSituationInvestigationResult: "利用状況調査結果コード",
      OwnerStatementIntentSurveyResults: "所有者等の廃地の状況",
      UseIntentionAscertainmentResult: "利用意向把握結果コード",
      RecommendationContenDate: "勧告内容日",
      RightOfMiddleManagement: "農地中間管理権の状況",
      OazaCode: "大字コード",
      TodofukenCode: "都道府県コード",
      ShikuchosonCode: "市区町村コード"
    };

    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19, attribution: "© OpenStreetMap"
    });
    const esriSat = L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
        attribution: "Tiles © Esri"
      }
    );

    const map = L.map("map", {
      center: [35.404, 132.825], zoom: 16, layers: [osm]
    });

    const polygonLayerGroup = L.layerGroup().addTo(map);
    const markerLayerGroup  = L.layerGroup().addTo(map);
    const tibanLayerGroup   = L.layerGroup().addTo(map);

    const baseMaps = { "地図": osm, "衛星画像": esriSat };
    const overlayMaps = {
      "筆ポリゴン": polygonLayerGroup,
      "農地ピン": markerLayerGroup,
      "地番ラベル": tibanLayerGroup
    };
    L.control.layers(baseMaps, overlayMaps).addTo(map);

    document.getElementById("fileInput").addEventListener("change", function(event) {
      const files = event.target.files;
      for (const file of files) {
        const reader = new FileReader();
        reader.onload = function(e) {
          let geojson;
          try {
            geojson = JSON.parse(e.target.result);
          } catch {
            alert("ファイルの読み込みに失敗: " + file.name);
            return;
          }
          L.geoJSON(geojson, {
            style: function(feature) {
              if (feature.geometry.type === "Polygon" || feature.geometry.type === "MultiPolygon") {
                return {
                  color: "#d00",
                  weight: 2,
                  fillColor: "#e88",
                  fillOpacity: 0.3
                };
              }
            },
            onEachFeature: function(feature, lyr) {
              // ポリゴン
              if (feature.geometry.type === "Polygon") {
                polygonLayerGroup.addLayer(lyr);
                if (feature.properties && feature.properties.Tiban && feature.geometry.coordinates && feature.geometry.coordinates.length > 0) {
                  const coords = feature.geometry.coordinates[0][0];
                  const tibanLabel = L.marker([coords[1], coords[0]], {
                    icon: L.divIcon({
                      className: "tiban-label",
                      html: String(feature.properties.Tiban),
                      iconSize: null
                    }),
                    interactive: false
                  });
                  tibanLayerGroup.addLayer(tibanLabel);
                }
                lyr.on('click', function () {
                  showProperties(feature.properties);
                });
              }
              // マルチポリゴン
              else if (feature.geometry.type === "MultiPolygon") {
                polygonLayerGroup.addLayer(lyr);
                if (feature.properties && feature.properties.Tiban && feature.geometry.coordinates && feature.geometry.coordinates.length > 0) {
                  const coords = feature.geometry.coordinates[0][0][0];
                  const tibanLabel = L.marker([coords[1], coords[0]], {
                    icon: L.divIcon({
                      className: "tiban-label",
                      html: String(feature.properties.Tiban),
                      iconSize: null
                    }),
                    interactive: false
                  });
                  tibanLayerGroup.addLayer(tibanLabel);
                }
                lyr.on('click', function () {
                  showProperties(feature.properties);
                });
              }
              // ポイント・ピン
              else if (feature.geometry.type === "Point") {
                const latlng = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]];
                const marker = L.marker(latlng, {
                  icon: L.icon({
                    iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",
                    shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
                    iconSize: [25,41],
                    iconAnchor: [12,41],
                    popupAnchor: [1,-34],
                    shadowSize: [41,41]
                  })
                });
                markerLayerGroup.addLayer(marker);
                marker.on('click', function () {
                  showProperties(feature.properties);
                });
                if (feature.properties && feature.properties.Tiban) {
                  const tibanLabel = L.marker(latlng, {
                    icon: L.divIcon({
                      className: "tiban-label",
                      html: String(feature.properties.Tiban),
                      iconSize: null
                    }),
                    interactive: false
                  });
                  tibanLayerGroup.addLayer(tibanLabel);
                }
              }
            }
          });
        };
        reader.readAsText(file);
      }
    });

    function showProperties(props) {
      let html = "<table>";
      for (const key in props) {
        const jp = propertyLabels[key] ? propertyLabels[key] : "（訳なし）";
        html += `<tr><td>${key}<br><span style='font-size:11px;color:#444'>${jp}</span></td><td>${props[key]}</td></tr>`;
      }
      html += "</table>";
      document.getElementById("details").innerHTML = html;
    }
  </script>
</body>
</html>
