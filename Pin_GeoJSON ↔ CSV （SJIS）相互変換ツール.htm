<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>SJIS Polygon GeoJSON ↔ CSV 相互変換ツール</title>
  <style>
    body{font-family:sans-serif;margin:20px;background:#f4f4f4;color:#333}
    h1{color:#0056b3;text-align:center;margin-bottom:30px}
    .container{max-width:1000px;margin:0 auto;background:#fff;padding:25px;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.1)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:20px}
    .section{border:1px solid #e0e0e0;border-radius:6px;padding:15px}
    h2{color:#007bff;border-bottom:1px solid #e0e0e0;padding-bottom:10px;margin-top:0}
    input[type=file]{margin-bottom:12px;padding:8px;border:1px solid #ddd;border-radius:4px;background:#f9f9f9;width:100%;box-sizing:border-box}
    textarea{width:100%;height:200px;margin:6px 0 12px;padding:10px;border:1px solid #ddd;border-radius:4px;font-family:monospace;box-sizing:border-box;resize:vertical}
    button{padding:10px 16px;background:#007bff;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:15px;margin-right:8px;margin-top:4px}
    button:hover{background:#0056b3}
    button:active{background:#004085}
    .note{font-size:.9em;color:#666;line-height:1.5}
    .message{margin-top:8px;min-height:1.2em;white-space:pre-wrap}
    .error{color:#c00}
    .warn{color:#b36b00}
    .ok{color:#0a7f2e}
    .output h3{margin:10px 0}
  </style>
</head>
<body>
  <div class="container">
    <h1>SJIS Polygon GeoJSON ↔ CSV 相互変換ツール</h1>
    <p class="note">
      - 右（CSV→GeoJSON）は Shift_JIS のCSV入力に対応します。<br>
      - 左（GeoJSON→CSV）は出力CSVを Shift_JIS でダウンロードします。<br>
      - ジオメトリは Polygon を想定し、CSVには `geometry_type` と `geometry_wkt` を出力・復元します。<br>
      - プロパティ列はCSVにそのまま展開され、復元時は同名列を properties として戻します。<br>
      - WKTは POLYGON のみサポート（MULTIPOLYGON 等は必要なら拡張可能）。
    </p>

    <div class="grid">
      <!-- 左: GeoJSON -> CSV (出力SJIS) -->
      <div class="section">
        <h2>GeoJSON → CSV（出力: Shift_JIS）</h2>
        <p class="note">
          - 入力GeoJSONは FeatureCollection で Polygon を含むことを想定します。<br>
          - CSVには `geometry_type` と `geometry_wkt` を生成し、プロパティ列はアルファベット順で展開します。
        </p>
        <label for="geojsonText">GeoJSONテキストを貼り付け:</label>
        <textarea id="geojsonText" placeholder='{"type":"FeatureCollection","features":[{"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[132.84,35.40],[...]]]},"properties":{"name":"A"}}]}'></textarea>
        <label for="geojsonFile">または GeoJSONファイルを選択（UTF-8）:</label>
        <input type="file" id="geojsonFile" accept=".json,.geojson" />
        <div>
          <button id="btnG2C">CSVに変換（SJISでDL）</button>
          <button id="btnG2CPreview">CSVをプレビュー（画面表示）</button>
        </div>
        <div id="msgG2C" class="message"></div>
        <div class="output">
          <h3>CSVプレビュー</h3>
          <textarea id="csvPreview" readonly></textarea>
        </div>
      </div>

      <!-- 右: CSV -> GeoJSON (入力SJIS) -->
      <div class="section">
        <h2>CSV（Shift_JIS） → GeoJSON</h2>
        <p class="note">
          - ヘッダーに `geometry_type` と `geometry_wkt` が必要です（Polygon想定）。<br>
          - SJISのCSVファイルを選択するか、下にSJISテキストを貼ってください（貼付時はブラウザ解釈に依存します）。
        </p>
        <label for="csvFile">SJIS CSVファイルを選択:</label>
        <input type="file" id="csvFile" accept=".csv" />
        <label for="csvText">または CSVテキストを貼り付け（SJISは文字化けの可能性あり）:</label>
        <textarea id="csvText" placeholder='geometry_type,geometry_wkt,name
Polygon,"POLYGON((132.84 35.40, 132.85 35.40, 132.85 35.39, 132.84 35.39, 132.84 35.40))",A'></textarea>
        <div>
          <button id="btnC2G">GeoJSONに変換</button>
          <button id="btnC2GDL">GeoJSONをダウンロード</button>
        </div>
        <div id="msgC2G" class="message"></div>
        <div class="output">
          <h3>GeoJSON出力</h3>
          <textarea id="geojsonOutput" readonly></textarea>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------------- 共通CSVユーティリティ ----------------
    function escapeCsvValue(value) {
      if (value === null || value === undefined) return '';
      let s = String(value);
      if (s.includes(',') || s.includes('"') || s.includes('\n') || s.includes('\r')) {
        s = '"' + s.replace(/"/g, '""') + '"';
      }
      return s;
    }
    function unescapeCsvValue(value) {
      if (typeof value !== 'string') return value;
      if (value.startsWith('"') && value.endsWith('"')) {
        return value.slice(1, -1).replace(/""/g, '"');
      }
      return value;
    }
    function parseCsvLine(line) {
      const values = [];
      let inQuote = false, cur = '';
      for (let i = 0; i < line.length; i++) {
        const c = line[i];
        if (c === '"') {
          if (inQuote && i + 1 < line.length && line[i + 1] === '"') { cur += '"'; i++; }
          else inQuote = !inQuote;
        } else if (c === ',' && !inQuote) {
          values.push(cur); cur = '';
        } else {
          cur += c;
        }
      }
      values.push(cur);
      return values;
    }

    // ---------------- GeoJSON <-> WKT（Polygon） ----------------
    function geometryToWkt(geometry) {
      if (!geometry || !geometry.type || !geometry.coordinates) return '';
      const type = geometry.type.toUpperCase();
      if (type !== 'POLYGON') return ''; // 本ツールはPolygonのみ
      const coords = geometry.coordinates;
      function formatPoint(pt) { return pt[0] + ' ' + pt[1]; }
      function formatRing(ring) { return '(' + ring.map(formatPoint).join(', ') + ')'; }
      return 'POLYGON(' + coords.map(formatRing).join(', ') + ')';
    }
    function trimOuterParens(s) {
      s = s.trim();
      if (!s.startsWith('(')) return s;
      let depth = 0;
      for (let i = 0; i < s.length; i++) {
        const ch = s[i];
        if (ch === '(') depth++;
        else if (ch === ')') { depth--; if (depth === 0 && i !== s.length - 1) return s; }
      }
      if (s.endsWith(')')) return s.slice(1, -1).trim();
      return s;
    }
    function splitTopLevel(s) {
      const parts = [];
      let cur = '', depth = 0;
      for (let i = 0; i < s.length; i++) {
        const ch = s[i];
        if (ch === '(') { depth++; cur += ch; }
        else if (ch === ')') { depth--; cur += ch; }
        else if (ch === ',' && depth === 0) { parts.push(cur.trim()); cur = ''; }
        else cur += ch;
      }
      if (cur.trim() !== '') parts.push(cur.trim());
      return parts;
    }
    function parsePointCoords(text) {
      const nums = text.trim().split(/\s+/).map(Number).filter(v => !Number.isNaN(v));
      if (nums.length >= 2) return [nums[0], nums[1]];
      return null;
    }
    function parseRing(text) {
      const t = trimOuterParens(text);
      const parts = t.split(',').map(s => s.trim());
      const ring = [];
      for (const p of parts) {
        const pt = parsePointCoords(p);
        if (!pt) return null;
        ring.push(pt);
      }
      if (ring.length >= 3) {
        const f = ring[0], l = ring[ring.length - 1];
        if (f[0] !== l[0] || f[1] !== l[1]) ring.push([f[0], f[1]]);
      }
      if (ring.length < 4) return null;
      return ring;
    }
    function wktPolygonToGeojsonGeometry(wkt) {
      if (!wkt || typeof wkt !== 'string') return null;
      const s = wkt.trim();
      const m = s.match(/^POLYGON\s*($$.+$$)$/i);
      if (!m) return null;
      const inner = trimOuterParens(m[1]);
      const ringTexts = splitTopLevel(inner);
      const rings = [];
      for (const r of ringTexts) {
        const ring = parseRing(r);
        if (!ring) return null;
        rings.push(ring);
      }
      if (rings.length === 0) return null;
      return { type: 'Polygon', coordinates: rings };
    }

    // ---------------- GeoJSON -> CSV（SJISでDL or プレビュー） ----------------
    let csvPreviewStr = '';

    async function geojsonToCsvProcess(geojsonText) {
      const msgEl = document.getElementById('msgG2C');
      const previewEl = document.getElementById('csvPreview');
      msgEl.textContent = ''; previewEl.value = ''; csvPreviewStr = '';

      let data;
      try {
        data = JSON.parse(geojsonText);
      } catch (e) {
        msgEl.textContent = 'エラー: 無効なJSONです: ' + e.message;
        msgEl.className = 'message error';
        return null;
      }
      if (!data || data.type !== 'FeatureCollection' || !Array.isArray(data.features)) {
        msgEl.textContent = "エラー: 'FeatureCollection' 形式が必要です。";
        msgEl.className = 'message error';
        return null;
      }
      const features = data.features || [];
      if (features.length === 0) {
        msgEl.textContent = '変換対象のFeatureがありません。';
        msgEl.className = 'message warn';
        return null;
      }

      // プロパティ列収集
      const propSet = new Set();
      for (const f of features) {
        const props = f && f.properties ? f.properties : {};
        Object.keys(props).forEach(k => propSet.add(k));
      }
      const propHeaders = Array.from(propSet).sort();

      const headers = ['geometry_type', 'geometry_wkt', ...propHeaders];
      const rows = [];
      rows.push(headers.map(escapeCsvValue).join(','));

      for (const f of features) {
        const geom = f.geometry || null;
        const props = f.properties || {};
        const row = [];
        const type = geom ? geom.type : '';
        row.push(escapeCsvValue(type));
        row.push(escapeCsvValue(geometryToWkt(geom)));
        for (const h of propHeaders) {
          row.push(escapeCsvValue(props.hasOwnProperty(h) ? props[h] : ''));
        }
        rows.push(row.join(','));
      }
      const csv = rows.join('\r\n');
      csvPreviewStr = csv;
      previewEl.value = csv;
      msgEl.textContent = 'GeoJSON → CSV 変換完了。プレビューに表示しました。';
      msgEl.className = 'message ok';
      return csv;
    }

    async function downloadCsvShiftJis(csv, baseName = 'geojson_data.csv') {
      const msgEl = document.getElementById('msgG2C');
      try {
        const enc = new TextEncoder('shift_jis', { NONSTANDARD_allowLegacyEncoding: true });
        // 一部ブラウザでは TextEncoder('shift_jis') 非対応。Polyfillがなければ ms932/SJISは不可。
        // フォールバック: Blobにcharset=shift_jisを指定しても実体はUTF-8になることがある点に注意。
        // 実運用で確実にSJISを得たい場合はサーバ側変換やencoding.js等のライブラリ使用を検討。
        const sjisSupported = (function(){ try{ new TextEncoder('shift_jis'); return true; } catch(e){ return false; } })();

        let blob;
        if (sjisSupported) {
          const bytes = new TextEncoder('shift_jis').encode(csv);
          blob = new Blob([bytes], { type: 'text/csv; charset=Shift_JIS' });
        } else {
          // 簡易フォールバック（実際はUTF-8になる可能性が高い）
          blob = new Blob([csv], { type: 'text/csv; charset=Shift_JIS' });
          msgEl.textContent = '注意: このブラウザはネイティブなSJISエンコードに未対応のため、UTF-8になる可能性があります。';
          msgEl.className = 'message warn';
        }

        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = baseName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (e) {
        msgEl.textContent = 'CSVダウンロード中にエラー: ' + e.message;
        msgEl.className = 'message error';
      }
    }

    // ---------------- CSV（SJIS） -> GeoJSON ----------------
    let lastGeojsonText = '';

    function parseCsvToRows(csvString) {
      const lines = csvString.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n').filter(l => l.trim() !== '');
      if (lines.length === 0) return [];
      const rows = [];
      for (const line of lines) rows.push(parseCsvLine(line));
      return rows;
    }

    function csvRowsToGeojson(rows, msgEl) {
      if (!rows || rows.length < 2) {
        msgEl.textContent = 'エラー: ヘッダーと少なくとも1行のデータが必要です。';
        msgEl.className = 'message error';
        return null;
      }
      const headers = rows[0].map(unescapeCsvValue);
      const idx = {};
      headers.forEach((h,i)=> idx[h]=i);

      if (!('geometry_type' in idx) || !('geometry_wkt' in idx)) {
        msgEl.textContent = "エラー: ヘッダーに 'geometry_type' と 'geometry_wkt' が必要です。";
        msgEl.className = 'message error';
        return null;
      }

      const features = [];
      for (let r = 1; r < rows.length; r++) {
        const row = rows[r];
        if (row.length !== headers.length) {
          msgEl.textContent += `\n警告(行 ${r + 1}): 列数が一致しません。スキップしました。`;
          msgEl.className = 'message warn';
          continue;
        }
        const get = name => unescapeCsvValue(row[idx[name]]);

        const type = get('geometry_type');
        const wkt = get('geometry_wkt');

        if (!wkt || !/^POLYGON/i.test(wkt || '')) {
          msgEl.textContent += `\n警告(行 ${r + 1}): WKTがPOLYGONではありません。スキップしました。`;
          msgEl.className = 'message warn';
          continue;
        }
        const geometry = wktPolygonToGeojsonGeometry(wkt);
        if (!geometry) {
          msgEl.textContent += `\n警告(行 ${r + 1}): WKT解析に失敗しました。スキップしました。`;
          msgEl.className = 'message warn';
          continue;
        }
        const properties = {};
        for (const h of headers) {
          if (h === 'geometry_type' || h === 'geometry_wkt') continue;
          properties[h] = unescapeCsvValue(row[idx[h]]);
        }
        features.push({ type: 'Feature', geometry, properties });
      }
      const geojson = { type: 'FeatureCollection', features };
      return geojson;
    }

    async function readFileAsShiftJis(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(reader.error);
        reader.readAsText(file, 'Shift_JIS');
      });
    }

    // ---------------- イベント配線 ----------------
    document.getElementById('btnG2C').addEventListener('click', async () => {
      const fileEl = document.getElementById('geojsonFile');
      const textEl = document.getElementById('geojsonText');
      const msgEl = document.getElementById('msgG2C');

      let geojsonText = textEl.value.trim();
      if (!geojsonText && fileEl.files[0]) {
        try {
          geojsonText = await fileEl.files[0].text(); // UTF-8として読む
        } catch (e) {
          msgEl.textContent = 'ファイル読み込みエラー: ' + e.message;
          msgEl.className = 'message error';
          return;
        }
      }
      if (!geojsonText) {
        msgEl.textContent = 'GeoJSONテキストを入力するかファイルを選択してください。';
        msgEl.className = 'message error';
        return;
      }
      const csv = await geojsonToCsvProcess(geojsonText);
      if (!csv) return;
      // ダウンロード名
      let name = 'geojson_data.csv';
      if (fileEl.files[0]) {
        const original = fileEl.files[0].name;
        const i = original.lastIndexOf('.');
        name = (i>0 ? original.slice(0,i) : original) + '.csv';
      }
      downloadCsvShiftJis(csv, name);
    });

    document.getElementById('btnG2CPreview').addEventListener('click', async () => {
      const fileEl = document.getElementById('geojsonFile');
      const textEl = document.getElementById('geojsonText');
      const msgEl = document.getElementById('msgG2C');

      let geojsonText = textEl.value.trim();
      if (!geojsonText && fileEl.files[0]) {
        try {
          geojsonText = await fileEl.files[0].text();
        } catch (e) {
          msgEl.textContent = 'ファイル読み込みエラー: ' + e.message;
          msgEl.className = 'message error';
          return;
        }
      }
      if (!geojsonText) {
        msgEl.textContent = 'GeoJSONテキストを入力するかファイルを選択してください。';
        msgEl.className = 'message error';
        return;
      }
      await geojsonToCsvProcess(geojsonText);
    });

    document.getElementById('btnC2G').addEventListener('click', async () => {
      const fileEl = document.getElementById('csvFile');
      const textEl = document.getElementById('csvText');
      const msgEl = document.getElementById('msgC2G');
      const outEl = document.getElementById('geojsonOutput');

      msgEl.textContent = ''; outEl.value = ''; lastGeojsonText = '';

      let csvText = textEl.value.trim();
      if (!csvText && fileEl.files[0]) {
        try {
          csvText = await readFileAsShiftJis(fileEl.files[0]);
        } catch (e) {
          msgEl.textContent = 'CSV(SJIS)読み込みエラー: ' + e.message;
          msgEl.className = 'message error';
          return;
        }
      }
      if (!csvText) {
        msgEl.textContent = 'CSVファイル（SJIS）を選択するか、CSVテキストを入力してください。';
        msgEl.className = 'message error';
        return;
      }
      const rows = parseCsvToRows(csvText);
      const geojson = csvRowsToGeojson(rows, msgEl);
      if (!geojson) return;
      lastGeojsonText = JSON.stringify(geojson, null, 2);
      outEl.value = lastGeojsonText;
      msgEl.textContent = (msgEl.textContent ? msgEl.textContent + '\n' : '') + 'CSV → GeoJSON 変換完了。';
      msgEl.className = 'message ok';
    });

    document.getElementById('btnC2GDL').addEventListener('click', () => {
      const msgEl = document.getElementById('msgC2G');
      if (!lastGeojsonText) {
        msgEl.textContent = 'ダウンロードするGeoJSONがありません。先に「GeoJSONに変換」を実行してください。';
        msgEl.className = 'message error';
        return;
      }
      let name = 'converted.geojson';
      const fileEl = document.getElementById('csvFile');
      if (fileEl.files[0]) {
        const original = fileEl.files[0].name;
        const i = original.lastIndexOf('.');
        name = (i>0 ? original.slice(0,i) : original) + '.geojson';
      }
      const blob = new Blob([lastGeojsonText], { type: 'application/json;charset=utf-8;' });
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url; a.download = name;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>